<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wayland++: wayland::xdg_toplevel_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wayland++
   &#160;<span id="projectnumber">0.2.6</span>
   </div>
   <div id="projectbrief">C++ Bindings for Wayland</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classwayland_1_1xdg__toplevel__t.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classwayland_1_1xdg__toplevel__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">wayland::xdg_toplevel_t Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>toplevel surface  
 <a href="classwayland_1_1xdg__toplevel__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for wayland::xdg_toplevel_t:</div>
<div class="dyncontent">
<div class="center"><img src="classwayland_1_1xdg__toplevel__t__inherit__graph.png" border="0" usemap="#wayland_1_1xdg__toplevel__t_inherit__map" alt="Inheritance graph"/></div>
<map name="wayland_1_1xdg__toplevel__t_inherit__map" id="wayland_1_1xdg__toplevel__t_inherit__map">
<area shape="rect" title="toplevel surface" alt="" coords="5,80,187,107"/>
<area shape="rect" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side." alt="" coords="29,5,163,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for wayland::xdg_toplevel_t:</div>
<div class="dyncontent">
<div class="center"><img src="classwayland_1_1xdg__toplevel__t__coll__graph.png" border="0" usemap="#wayland_1_1xdg__toplevel__t_coll__map" alt="Collaboration graph"/></div>
<map name="wayland_1_1xdg__toplevel__t_coll__map" id="wayland_1_1xdg__toplevel__t_coll__map">
<area shape="rect" title="toplevel surface" alt="" coords="5,80,187,107"/>
<area shape="rect" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side." alt="" coords="29,5,163,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afc44f0d53890db6bd32d9b2f0c6994e9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9">wrapper_type</a> { <a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9ac00f0c4675b91fb8b918e4079a0b1bac">wrapper_type::standard</a>, 
<a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9aebf78b512222fe4dcd14e7d5060a15b0">wrapper_type::display</a>, 
<a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9a684a72e08f24f55b1138edd5a7c2b53e">wrapper_type::foreign</a>, 
<a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9ae6cc1490287e90290ddd4e0b9efeb6d5">wrapper_type::proxy_wrapper</a>
 }</td></tr>
<tr class="separator:afc44f0d53890db6bd32d9b2f0c6994e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab9b32e22ab7edb7e527effd7991be260"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#ab9b32e22ab7edb7e527effd7991be260">set_parent</a> (<a class="el" href="classwayland_1_1xdg__toplevel__t.html">xdg_toplevel_t</a> parent)</td></tr>
<tr class="memdesc:ab9b32e22ab7edb7e527effd7991be260"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the parent of this surface  <a href="classwayland_1_1xdg__toplevel__t.html#ab9b32e22ab7edb7e527effd7991be260">More...</a><br /></td></tr>
<tr class="separator:ab9b32e22ab7edb7e527effd7991be260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e4632d00f4b52b96c3706081d4d9bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a45e4632d00f4b52b96c3706081d4d9bf">set_title</a> (std::string title)</td></tr>
<tr class="memdesc:a45e4632d00f4b52b96c3706081d4d9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">set surface title  <a href="classwayland_1_1xdg__toplevel__t.html#a45e4632d00f4b52b96c3706081d4d9bf">More...</a><br /></td></tr>
<tr class="separator:a45e4632d00f4b52b96c3706081d4d9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795aaf0eb3f578ae2eea5b163e7d2fc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a795aaf0eb3f578ae2eea5b163e7d2fc1">set_app_id</a> (std::string app_id)</td></tr>
<tr class="memdesc:a795aaf0eb3f578ae2eea5b163e7d2fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">set application ID  <a href="classwayland_1_1xdg__toplevel__t.html#a795aaf0eb3f578ae2eea5b163e7d2fc1">More...</a><br /></td></tr>
<tr class="separator:a795aaf0eb3f578ae2eea5b163e7d2fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a937bcde98359c96b89a542ea572114"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a2a937bcde98359c96b89a542ea572114">show_window_menu</a> (<a class="el" href="classwayland_1_1seat__t.html">seat_t</a> seat, uint32_t serial, int32_t x, int32_t y)</td></tr>
<tr class="memdesc:a2a937bcde98359c96b89a542ea572114"><td class="mdescLeft">&#160;</td><td class="mdescRight">show the window menu  <a href="classwayland_1_1xdg__toplevel__t.html#a2a937bcde98359c96b89a542ea572114">More...</a><br /></td></tr>
<tr class="separator:a2a937bcde98359c96b89a542ea572114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a661a96ec48e08fd3b58a5f604ad55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a81a661a96ec48e08fd3b58a5f604ad55">move</a> (<a class="el" href="classwayland_1_1seat__t.html">seat_t</a> seat, uint32_t serial)</td></tr>
<tr class="memdesc:a81a661a96ec48e08fd3b58a5f604ad55"><td class="mdescLeft">&#160;</td><td class="mdescRight">start an interactive move  <a href="classwayland_1_1xdg__toplevel__t.html#a81a661a96ec48e08fd3b58a5f604ad55">More...</a><br /></td></tr>
<tr class="separator:a81a661a96ec48e08fd3b58a5f604ad55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5102efd2c01ad56eb5811887a7df1e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#af5102efd2c01ad56eb5811887a7df1e6">resize</a> (<a class="el" href="classwayland_1_1seat__t.html">seat_t</a> seat, uint32_t serial, <a class="el" href="structwayland_1_1xdg__toplevel__resize__edge.html">xdg_toplevel_resize_edge</a> edges)</td></tr>
<tr class="memdesc:af5102efd2c01ad56eb5811887a7df1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">start an interactive resize  <a href="classwayland_1_1xdg__toplevel__t.html#af5102efd2c01ad56eb5811887a7df1e6">More...</a><br /></td></tr>
<tr class="separator:af5102efd2c01ad56eb5811887a7df1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608d327530e874ed666a0eff8d8fb259"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a608d327530e874ed666a0eff8d8fb259">set_max_size</a> (int32_t width, int32_t height)</td></tr>
<tr class="memdesc:a608d327530e874ed666a0eff8d8fb259"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the maximum size  <a href="classwayland_1_1xdg__toplevel__t.html#a608d327530e874ed666a0eff8d8fb259">More...</a><br /></td></tr>
<tr class="separator:a608d327530e874ed666a0eff8d8fb259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539a675afe84f545ed9b05824e0a99e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a539a675afe84f545ed9b05824e0a99e3">set_min_size</a> (int32_t width, int32_t height)</td></tr>
<tr class="memdesc:a539a675afe84f545ed9b05824e0a99e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the minimum size  <a href="classwayland_1_1xdg__toplevel__t.html#a539a675afe84f545ed9b05824e0a99e3">More...</a><br /></td></tr>
<tr class="separator:a539a675afe84f545ed9b05824e0a99e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d7485f59eeec328335d1fe86fca9f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a55d7485f59eeec328335d1fe86fca9f4">set_maximized</a> ()</td></tr>
<tr class="memdesc:a55d7485f59eeec328335d1fe86fca9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximize the window  <a href="classwayland_1_1xdg__toplevel__t.html#a55d7485f59eeec328335d1fe86fca9f4">More...</a><br /></td></tr>
<tr class="separator:a55d7485f59eeec328335d1fe86fca9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3a7b00545369856391a56faebb10b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#aff3a7b00545369856391a56faebb10b6">unset_maximized</a> ()</td></tr>
<tr class="memdesc:aff3a7b00545369856391a56faebb10b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">unmaximize the window  <a href="classwayland_1_1xdg__toplevel__t.html#aff3a7b00545369856391a56faebb10b6">More...</a><br /></td></tr>
<tr class="separator:aff3a7b00545369856391a56faebb10b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6ace340b03217a048f41644ca6794c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a2c6ace340b03217a048f41644ca6794c">set_fullscreen</a> (<a class="el" href="classwayland_1_1output__t.html">output_t</a> output)</td></tr>
<tr class="memdesc:a2c6ace340b03217a048f41644ca6794c"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the window as fullscreen on an output  <a href="classwayland_1_1xdg__toplevel__t.html#a2c6ace340b03217a048f41644ca6794c">More...</a><br /></td></tr>
<tr class="separator:a2c6ace340b03217a048f41644ca6794c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3836376d6911ff739218f2d7e462b46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#af3836376d6911ff739218f2d7e462b46">unset_fullscreen</a> ()</td></tr>
<tr class="memdesc:af3836376d6911ff739218f2d7e462b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">unset the window as fullscreen  <a href="classwayland_1_1xdg__toplevel__t.html#af3836376d6911ff739218f2d7e462b46">More...</a><br /></td></tr>
<tr class="separator:af3836376d6911ff739218f2d7e462b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2c02efb228b17f19e6d436ae523e94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a7e2c02efb228b17f19e6d436ae523e94">set_minimized</a> ()</td></tr>
<tr class="memdesc:a7e2c02efb228b17f19e6d436ae523e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the window as minimized  <a href="classwayland_1_1xdg__toplevel__t.html#a7e2c02efb228b17f19e6d436ae523e94">More...</a><br /></td></tr>
<tr class="separator:a7e2c02efb228b17f19e6d436ae523e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fabc21ab7eabf69f1cc3a5f9a8a5b2"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(int32_t, int32_t, array_t)&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a54fabc21ab7eabf69f1cc3a5f9a8a5b2">on_configure</a> ()</td></tr>
<tr class="memdesc:a54fabc21ab7eabf69f1cc3a5f9a8a5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">suggest a surface change  <a href="classwayland_1_1xdg__toplevel__t.html#a54fabc21ab7eabf69f1cc3a5f9a8a5b2">More...</a><br /></td></tr>
<tr class="separator:a54fabc21ab7eabf69f1cc3a5f9a8a5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27068a7df29fe7b29e12b5eb71c984a1"><td class="memItemLeft" align="right" valign="top">std::function&lt; void()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a27068a7df29fe7b29e12b5eb71c984a1">on_close</a> ()</td></tr>
<tr class="memdesc:a27068a7df29fe7b29e12b5eb71c984a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">surface wants to be closed  <a href="classwayland_1_1xdg__toplevel__t.html#a27068a7df29fe7b29e12b5eb71c984a1">More...</a><br /></td></tr>
<tr class="separator:a27068a7df29fe7b29e12b5eb71c984a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273d7fd6604b65d4c4d24747b639a263"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a273d7fd6604b65d4c4d24747b639a263">get_id</a> () const</td></tr>
<tr class="memdesc:a273d7fd6604b65d4c4d24747b639a263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of a proxy object.  <a href="classwayland_1_1proxy__t.html#a273d7fd6604b65d4c4d24747b639a263">More...</a><br /></td></tr>
<tr class="separator:a273d7fd6604b65d4c4d24747b639a263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a77c6eab2f2eb4cfcca56be8a780d3e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a8a77c6eab2f2eb4cfcca56be8a780d3e">get_class</a> () const</td></tr>
<tr class="memdesc:a8a77c6eab2f2eb4cfcca56be8a780d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interface name (class) of a proxy object.  <a href="classwayland_1_1proxy__t.html#a8a77c6eab2f2eb4cfcca56be8a780d3e">More...</a><br /></td></tr>
<tr class="separator:a8a77c6eab2f2eb4cfcca56be8a780d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59444022b75257f6b27d2c464c371779"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a59444022b75257f6b27d2c464c371779">get_version</a> () const</td></tr>
<tr class="memdesc:a59444022b75257f6b27d2c464c371779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the protocol object version of a proxy object.  <a href="classwayland_1_1proxy__t.html#a59444022b75257f6b27d2c464c371779">More...</a><br /></td></tr>
<tr class="separator:a59444022b75257f6b27d2c464c371779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65253c6ac727496735c0dc42a9fd1568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9">wrapper_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a65253c6ac727496735c0dc42a9fd1568">get_wrapper_type</a> () const</td></tr>
<tr class="memdesc:a65253c6ac727496735c0dc42a9fd1568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of a proxy object.  <a href="classwayland_1_1proxy__t.html#a65253c6ac727496735c0dc42a9fd1568">More...</a><br /></td></tr>
<tr class="separator:a65253c6ac727496735c0dc42a9fd1568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2065bb6f0ba51f29fdf16b8168bb5958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a2065bb6f0ba51f29fdf16b8168bb5958">set_queue</a> (<a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a> queue)</td></tr>
<tr class="memdesc:a2065bb6f0ba51f29fdf16b8168bb5958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a proxy to an event queue.  <a href="classwayland_1_1proxy__t.html#a2065bb6f0ba51f29fdf16b8168bb5958">More...</a><br /></td></tr>
<tr class="separator:a2065bb6f0ba51f29fdf16b8168bb5958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9f256a9bfaed12ad36a357cc22df5e"><td class="memItemLeft" align="right" valign="top">wl_proxy *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a6a9f256a9bfaed12ad36a357cc22df5e">c_ptr</a> () const</td></tr>
<tr class="memdesc:a6a9f256a9bfaed12ad36a357cc22df5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the underlying C struct.  <a href="classwayland_1_1proxy__t.html#a6a9f256a9bfaed12ad36a357cc22df5e">More...</a><br /></td></tr>
<tr class="separator:a6a9f256a9bfaed12ad36a357cc22df5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c596640d7469447cb0b91dc9c8c22b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a0c596640d7469447cb0b91dc9c8c22b2">proxy_has_object</a> () const</td></tr>
<tr class="memdesc:a0c596640d7469447cb0b91dc9c8c22b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this wrapper actually wraps an object.  <a href="classwayland_1_1proxy__t.html#a0c596640d7469447cb0b91dc9c8c22b2">More...</a><br /></td></tr>
<tr class="separator:a0c596640d7469447cb0b91dc9c8c22b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa72a9121fa69ccfad6e9eff8740b5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#aafa72a9121fa69ccfad6e9eff8740b5e">operator bool</a> () const</td></tr>
<tr class="memdesc:aafa72a9121fa69ccfad6e9eff8740b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this wrapper actually wraps an object.  <a href="classwayland_1_1proxy__t.html#aafa72a9121fa69ccfad6e9eff8740b5e">More...</a><br /></td></tr>
<tr class="separator:aafa72a9121fa69ccfad6e9eff8740b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc433db4597e77caccb07f99b26a259"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a3dc433db4597e77caccb07f99b26a259">operator==</a> (const <a class="el" href="classwayland_1_1proxy__t.html">proxy_t</a> &amp;right) const</td></tr>
<tr class="memdesc:a3dc433db4597e77caccb07f99b26a259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two wrappers refer to the same object.  <a href="classwayland_1_1proxy__t.html#a3dc433db4597e77caccb07f99b26a259">More...</a><br /></td></tr>
<tr class="separator:a3dc433db4597e77caccb07f99b26a259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac460e26f384624eb96647d533314240a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#ac460e26f384624eb96647d533314240a">operator!=</a> (const <a class="el" href="classwayland_1_1proxy__t.html">proxy_t</a> &amp;right) const</td></tr>
<tr class="memdesc:ac460e26f384624eb96647d533314240a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two wrappers refer to different objects.  <a href="classwayland_1_1proxy__t.html#ac460e26f384624eb96647d533314240a">More...</a><br /></td></tr>
<tr class="separator:ac460e26f384624eb96647d533314240a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af69af8f839a5a5ea354e52705e9a43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a0af69af8f839a5a5ea354e52705e9a43">proxy_release</a> ()</td></tr>
<tr class="memdesc:a0af69af8f839a5a5ea354e52705e9a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the wrapped object (if any), making this an empty wrapper.  <a href="classwayland_1_1proxy__t.html#a0af69af8f839a5a5ea354e52705e9a43">More...</a><br /></td></tr>
<tr class="separator:a0af69af8f839a5a5ea354e52705e9a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af046c8fd5dc6ca06ae5448e6b99a15f2"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#af046c8fd5dc6ca06ae5448e6b99a15f2">set_parent_since_version</a> = 1</td></tr>
<tr class="memdesc:af046c8fd5dc6ca06ae5448e6b99a15f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#ab9b32e22ab7edb7e527effd7991be260">set_parent</a> function.  <a href="classwayland_1_1xdg__toplevel__t.html#af046c8fd5dc6ca06ae5448e6b99a15f2">More...</a><br /></td></tr>
<tr class="separator:af046c8fd5dc6ca06ae5448e6b99a15f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8144c4e9d92be847d49a214d7b7f3f"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#acb8144c4e9d92be847d49a214d7b7f3f">set_title_since_version</a> = 1</td></tr>
<tr class="memdesc:acb8144c4e9d92be847d49a214d7b7f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a45e4632d00f4b52b96c3706081d4d9bf">set_title</a> function.  <a href="classwayland_1_1xdg__toplevel__t.html#acb8144c4e9d92be847d49a214d7b7f3f">More...</a><br /></td></tr>
<tr class="separator:acb8144c4e9d92be847d49a214d7b7f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ca71b4589293fa6686802a7be2fcc5"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a71ca71b4589293fa6686802a7be2fcc5">set_app_id_since_version</a> = 1</td></tr>
<tr class="memdesc:a71ca71b4589293fa6686802a7be2fcc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a795aaf0eb3f578ae2eea5b163e7d2fc1">set_app_id</a> function.  <a href="classwayland_1_1xdg__toplevel__t.html#a71ca71b4589293fa6686802a7be2fcc5">More...</a><br /></td></tr>
<tr class="separator:a71ca71b4589293fa6686802a7be2fcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cbd4703095deafbf6d4c6d71f6d27d"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a76cbd4703095deafbf6d4c6d71f6d27d">show_window_menu_since_version</a> = 1</td></tr>
<tr class="memdesc:a76cbd4703095deafbf6d4c6d71f6d27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a2a937bcde98359c96b89a542ea572114">show_window_menu</a> function.  <a href="classwayland_1_1xdg__toplevel__t.html#a76cbd4703095deafbf6d4c6d71f6d27d">More...</a><br /></td></tr>
<tr class="separator:a76cbd4703095deafbf6d4c6d71f6d27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae85a7f08f5c9e653f0f50cb00e38ac1"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#aae85a7f08f5c9e653f0f50cb00e38ac1">move_since_version</a> = 1</td></tr>
<tr class="memdesc:aae85a7f08f5c9e653f0f50cb00e38ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a81a661a96ec48e08fd3b58a5f604ad55">move</a> function.  <a href="classwayland_1_1xdg__toplevel__t.html#aae85a7f08f5c9e653f0f50cb00e38ac1">More...</a><br /></td></tr>
<tr class="separator:aae85a7f08f5c9e653f0f50cb00e38ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3e48f7ab2117ded9f776d745aa3c6f"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a2f3e48f7ab2117ded9f776d745aa3c6f">resize_since_version</a> = 1</td></tr>
<tr class="memdesc:a2f3e48f7ab2117ded9f776d745aa3c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#af5102efd2c01ad56eb5811887a7df1e6">resize</a> function.  <a href="classwayland_1_1xdg__toplevel__t.html#a2f3e48f7ab2117ded9f776d745aa3c6f">More...</a><br /></td></tr>
<tr class="separator:a2f3e48f7ab2117ded9f776d745aa3c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306252a421df25c6d2a828959c701a4a"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a306252a421df25c6d2a828959c701a4a">set_max_size_since_version</a> = 1</td></tr>
<tr class="memdesc:a306252a421df25c6d2a828959c701a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a608d327530e874ed666a0eff8d8fb259">set_max_size</a> function.  <a href="classwayland_1_1xdg__toplevel__t.html#a306252a421df25c6d2a828959c701a4a">More...</a><br /></td></tr>
<tr class="separator:a306252a421df25c6d2a828959c701a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d426a247cb109dcb4ea57750d57614"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a64d426a247cb109dcb4ea57750d57614">set_min_size_since_version</a> = 1</td></tr>
<tr class="memdesc:a64d426a247cb109dcb4ea57750d57614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a539a675afe84f545ed9b05824e0a99e3">set_min_size</a> function.  <a href="classwayland_1_1xdg__toplevel__t.html#a64d426a247cb109dcb4ea57750d57614">More...</a><br /></td></tr>
<tr class="separator:a64d426a247cb109dcb4ea57750d57614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6aea27211801288f3fc205c4b2891e2"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#ab6aea27211801288f3fc205c4b2891e2">set_maximized_since_version</a> = 1</td></tr>
<tr class="memdesc:ab6aea27211801288f3fc205c4b2891e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a55d7485f59eeec328335d1fe86fca9f4">set_maximized</a> function.  <a href="classwayland_1_1xdg__toplevel__t.html#ab6aea27211801288f3fc205c4b2891e2">More...</a><br /></td></tr>
<tr class="separator:ab6aea27211801288f3fc205c4b2891e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378646c9f2f2c65e44f62cfb23df6d48"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a378646c9f2f2c65e44f62cfb23df6d48">unset_maximized_since_version</a> = 1</td></tr>
<tr class="memdesc:a378646c9f2f2c65e44f62cfb23df6d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#aff3a7b00545369856391a56faebb10b6">unset_maximized</a> function.  <a href="classwayland_1_1xdg__toplevel__t.html#a378646c9f2f2c65e44f62cfb23df6d48">More...</a><br /></td></tr>
<tr class="separator:a378646c9f2f2c65e44f62cfb23df6d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3a43e8f977f5655f82f5de7ec08c86"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a5f3a43e8f977f5655f82f5de7ec08c86">set_fullscreen_since_version</a> = 1</td></tr>
<tr class="memdesc:a5f3a43e8f977f5655f82f5de7ec08c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a2c6ace340b03217a048f41644ca6794c">set_fullscreen</a> function.  <a href="classwayland_1_1xdg__toplevel__t.html#a5f3a43e8f977f5655f82f5de7ec08c86">More...</a><br /></td></tr>
<tr class="separator:a5f3a43e8f977f5655f82f5de7ec08c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba10a7706e227c7412b496896a414a41"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#aba10a7706e227c7412b496896a414a41">unset_fullscreen_since_version</a> = 1</td></tr>
<tr class="memdesc:aba10a7706e227c7412b496896a414a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#af3836376d6911ff739218f2d7e462b46">unset_fullscreen</a> function.  <a href="classwayland_1_1xdg__toplevel__t.html#aba10a7706e227c7412b496896a414a41">More...</a><br /></td></tr>
<tr class="separator:aba10a7706e227c7412b496896a414a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c885daa3622f76269c956b395831b8"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__toplevel__t.html#a78c885daa3622f76269c956b395831b8">set_minimized_since_version</a> = 1</td></tr>
<tr class="memdesc:a78c885daa3622f76269c956b395831b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a7e2c02efb228b17f19e6d436ae523e94">set_minimized</a> function.  <a href="classwayland_1_1xdg__toplevel__t.html#a78c885daa3622f76269c956b395831b8">More...</a><br /></td></tr>
<tr class="separator:a78c885daa3622f76269c956b395831b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>toplevel surface </p>
<p>This interface defines an xdg_surface role which allows a surface to, among other things, set window-like properties such as maximize, fullscreen, and minimize, set application-specific metadata like title and id, and well as trigger user interactive operations such as interactive resize and move.</p>
<p>Unmapping an xdg_toplevel means that the surface cannot be shown by the compositor until it is explicitly mapped again. All active operations (e.g., move, resize) are canceled and all attributes (e.g. title, state, stacking, ...) are discarded for an xdg_toplevel surface when it is unmapped.</p>
<p>Attaching a null buffer to a toplevel unmaps the surface. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="egl_8cpp-example.html#_a10">egl.cpp</a>, and <a class="el" href="shm_8cpp-example.html#_a10">shm.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01143">1143</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="afc44f0d53890db6bd32d9b2f0c6994e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc44f0d53890db6bd32d9b2f0c6994e9">&#9670;&nbsp;</a></span>wrapper_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9">wayland::proxy_t::wrapper_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Underlying wl_proxy type and properties of a <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> that affect construction, destruction, and event handling </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afc44f0d53890db6bd32d9b2f0c6994e9ac00f0c4675b91fb8b918e4079a0b1bac"></a>standard&#160;</td><td class="fielddoc"><p>C pointer is a standard type compatible with wl_proxy*. Events are dispatched and it is destructed when the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is destructed. User data is set. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc44f0d53890db6bd32d9b2f0c6994e9aebf78b512222fe4dcd14e7d5060a15b0"></a>display&#160;</td><td class="fielddoc"><p>C pointer is a wl_display*. No events are dispatched, wl_display_disconnect is called when the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is destructed. User data is set. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc44f0d53890db6bd32d9b2f0c6994e9a684a72e08f24f55b1138edd5a7c2b53e"></a>foreign&#160;</td><td class="fielddoc"><p>C pointer is a standard type compatible with wl_proxy*, but another library owns it and it should not be touched in a way that could affect the operation of the other library. No events are dispatched, wl_proxy_destroy is not called when the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is destructed, user data is not touched. Consequently, there is no reference counting for the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a>. Lifetime of such wrappers should preferably be short to minimize the chance that the owning library decides to destroy the wl_proxy. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc44f0d53890db6bd32d9b2f0c6994e9ae6cc1490287e90290ddd4e0b9efeb6d5"></a>proxy_wrapper&#160;</td><td class="fielddoc"><p>C pointer is a wl_proxy* that was constructed with wl_proxy_create_wrapper. No events are dispatched, wl_proxy_wrapper_destroy is called when the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is destroyed. Reference counting is active. A reference to the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> creating this proxy wrapper is held to extend its lifetime until after the proxy wrapper is destroyed. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="wayland-client_8hpp_source.html#l00105">105</a> of file <a class="el" href="wayland-client_8hpp_source.html">wayland-client.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6a9f256a9bfaed12ad36a357cc22df5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9f256a9bfaed12ad36a357cc22df5e">&#9670;&nbsp;</a></span>c_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wl_proxy* wayland::proxy_t::c_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the underlying C struct. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying wl_proxy wrapped by this <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> if it exists, otherwise an exception is thrown </dd></dl>

</div>
</div>
<a id="a8a77c6eab2f2eb4cfcca56be8a780d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a77c6eab2f2eb4cfcca56be8a780d3e">&#9670;&nbsp;</a></span>get_class()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string wayland::proxy_t::get_class </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the interface name (class) of a proxy object. </p>
<dl class="section return"><dt>Returns</dt><dd>The interface name of the object associated with the proxy </dd></dl>

</div>
</div>
<a id="a273d7fd6604b65d4c4d24747b639a263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273d7fd6604b65d4c4d24747b639a263">&#9670;&nbsp;</a></span>get_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t wayland::proxy_t::get_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the id of a proxy object. </p>
<dl class="section return"><dt>Returns</dt><dd>The id the object associated with the proxy </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="dump_8cpp-example.html#a6">dump.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a59444022b75257f6b27d2c464c371779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59444022b75257f6b27d2c464c371779">&#9670;&nbsp;</a></span>get_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t wayland::proxy_t::get_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the protocol object version of a proxy object. </p>
<p>Gets the protocol object version of a proxy object, or 0 if the proxy was created with unversioned API.</p>
<p>A returned value of 0 means that no version information is available, so the caller must make safe assumptions about the object's real version.</p>
<p><a class="el" href="classwayland_1_1display__t.html">display_t</a> will always return version 0.</p>
<dl class="section return"><dt>Returns</dt><dd>The protocol object version of the proxy or 0 </dd></dl>

</div>
</div>
<a id="a65253c6ac727496735c0dc42a9fd1568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65253c6ac727496735c0dc42a9fd1568">&#9670;&nbsp;</a></span>get_wrapper_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9">wrapper_type</a> wayland::proxy_t::get_wrapper_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of a proxy object. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client_8hpp_source.html#l00288">288</a> of file <a class="el" href="wayland-client_8hpp_source.html">wayland-client.hpp</a>.</p>

</div>
</div>
<a id="a81a661a96ec48e08fd3b58a5f604ad55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a661a96ec48e08fd3b58a5f604ad55">&#9670;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdg_toplevel_t::move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwayland_1_1seat__t.html">seat_t</a>&#160;</td>
          <td class="paramname"><em>seat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>serial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>start an interactive move </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seat</td><td>the wl_seat of the user event </td></tr>
    <tr><td class="paramname">serial</td><td>the serial of the user event</td></tr>
  </table>
  </dd>
</dl>
<p>Start an interactive, user-driven move of the surface.</p>
<p>This request must be used in response to some sort of user action like a button press, key press, or touch down event. The passed serial is used to determine the type of interactive move (touch, pointer, etc).</p>
<p>The server may ignore move requests depending on the state of the surface (e.g. fullscreen or maximized), or if the passed serial is no longer valid.</p>
<p>If triggered, the surface will lose the focus of the device (wl_pointer, wl_touch, etc) used for the move. It is up to the compositor to visually indicate that the move is taking place, such as updating a pointer cursor, during the move. There is no guarantee that the device focus will return when the move is completed. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="egl_8cpp-example.html#a48">egl.cpp</a>, and <a class="el" href="shm_8cpp-example.html#a48">shm.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01250">1250</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="a27068a7df29fe7b29e12b5eb71c984a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27068a7df29fe7b29e12b5eb71c984a1">&#9670;&nbsp;</a></span>on_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void()&gt; &amp; xdg_toplevel_t::on_close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>surface wants to be closed </p>
<p>The close event is sent by the compositor when the user wants the surface to be closed. This should be equivalent to the user clicking the close button in client-side decorations, if your application has any.</p>
<p>This is only a request that the user intends to close the window. The client may choose to ignore this request, or show a dialog to ask the user to save their data, etc. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="egl_8cpp-example.html#a34">egl.cpp</a>, and <a class="el" href="shm_8cpp-example.html#a36">shm.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01300">1300</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="a54fabc21ab7eabf69f1cc3a5f9a8a5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fabc21ab7eabf69f1cc3a5f9a8a5b2">&#9670;&nbsp;</a></span>on_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(int32_t, int32_t, array_t)&gt; &amp; xdg_toplevel_t::on_configure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>suggest a surface change </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">height</td><td></td></tr>
    <tr><td class="paramname">states</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>This configure event asks the client to resize its toplevel surface or to change its state. The configured state should not be applied immediately. See xdg_surface.configure for details.</p>
<p>The width and height arguments specify a hint to the window about how its surface should be resized in window geometry coordinates. See set_window_geometry.</p>
<p>If the width or height arguments are zero, it means the client should decide its own window dimension. This may happen when the compositor needs to configure the state of the surface but doesn't have any information about any previous or expected dimension.</p>
<p>The states listed in the event specify how the width/height arguments should be interpreted, and possibly how it should be drawn.</p>
<p>Clients must send an ack_configure in response to this event. See xdg_surface.configure and xdg_surface.ack_configure for details. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01295">1295</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="aafa72a9121fa69ccfad6e9eff8740b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa72a9121fa69ccfad6e9eff8740b5e">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wayland::proxy_t::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this wrapper actually wraps an object. </p>
<dl class="section return"><dt>Returns</dt><dd>true if there is an underlying object, false if this wrapper is empty </dd></dl>

</div>
</div>
<a id="ac460e26f384624eb96647d533314240a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac460e26f384624eb96647d533314240a">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wayland::proxy_t::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwayland_1_1proxy__t.html">proxy_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether two wrappers refer to different objects. </p>

</div>
</div>
<a id="a3dc433db4597e77caccb07f99b26a259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc433db4597e77caccb07f99b26a259">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wayland::proxy_t::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwayland_1_1proxy__t.html">proxy_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether two wrappers refer to the same object. </p>

</div>
</div>
<a id="a0c596640d7469447cb0b91dc9c8c22b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c596640d7469447cb0b91dc9c8c22b2">&#9670;&nbsp;</a></span>proxy_has_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wayland::proxy_t::proxy_has_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this wrapper actually wraps an object. </p>
<dl class="section return"><dt>Returns</dt><dd>true if there is an underlying object, false if this wrapper is empty </dd></dl>

</div>
</div>
<a id="a0af69af8f839a5a5ea354e52705e9a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af69af8f839a5a5ea354e52705e9a43">&#9670;&nbsp;</a></span>proxy_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wayland::proxy_t::proxy_release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the wrapped object (if any), making this an empty wrapper. </p>
<p>Note that <a class="el" href="classwayland_1_1display__t.html" title="Represents a connection to the compositor and acts as a proxy to the display singleton object.">display_t</a> instances cannot be released this way. Attempts to do so are ignored. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="foreign_display_8cpp-example.html#a1">foreign_display.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af5102efd2c01ad56eb5811887a7df1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5102efd2c01ad56eb5811887a7df1e6">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdg_toplevel_t::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwayland_1_1seat__t.html">seat_t</a>&#160;</td>
          <td class="paramname"><em>seat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwayland_1_1xdg__toplevel__resize__edge.html">xdg_toplevel_resize_edge</a>&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>start an interactive resize </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seat</td><td>the wl_seat of the user event </td></tr>
    <tr><td class="paramname">serial</td><td>the serial of the user event </td></tr>
    <tr><td class="paramname">edges</td><td>which edge or corner is being dragged</td></tr>
  </table>
  </dd>
</dl>
<p>Start a user-driven, interactive resize of the surface.</p>
<p>This request must be used in response to some sort of user action like a button press, key press, or touch down event. The passed serial is used to determine the type of interactive resize (touch, pointer, etc).</p>
<p>The server may ignore resize requests depending on the state of the surface (e.g. fullscreen or maximized).</p>
<p>If triggered, the client will receive configure events with the "resize" state enum value and the expected sizes. See the "resize" enum value for more details about what is required. The client must also acknowledge configure events using "ack_configure". After the resize is completed, the client will receive another "configure" event without the resize state.</p>
<p>If triggered, the surface also will lose the focus of the device (wl_pointer, wl_touch, etc) used for the resize. It is up to the compositor to visually indicate that the resize is taking place, such as updating a pointer cursor, during the resize. There is no guarantee that the device focus will return when the resize is completed.</p>
<p>The edges parameter specifies how the surface should be resized, and is one of the values of the resize_edge enum. The compositor may use this information to update the surface position for example when dragging the top left corner. The compositor may also use this information to adapt its behavior, e.g. choose an appropriate cursor image. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01255">1255</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="a795aaf0eb3f578ae2eea5b163e7d2fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795aaf0eb3f578ae2eea5b163e7d2fc1">&#9670;&nbsp;</a></span>set_app_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdg_toplevel_t::set_app_id </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>app_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set application ID </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app_id</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Set an application identifier for the surface.</p>
<p>The app ID identifies the general class of applications to which the surface belongs. The compositor can use this to group multiple surfaces together, or to determine how to launch a new application.</p>
<p>For D-Bus activatable applications, the app ID is used as the D-Bus service name.</p>
<p>The compositor shell will try to group application surfaces together by their app ID. As a best practice, it is suggested to select app ID's that match the basename of the application's .desktop file. For example, "org.freedesktop.FooViewer" where the .desktop file is "org.freedesktop.FooViewer.desktop".</p>
<p>Like other properties, a set_app_id request can be sent after the xdg_toplevel has been mapped to update the property.</p>
<p>See the desktop-entry specification [0] for more details on application identifiers and how they relate to well-known D-Bus names and .desktop files.</p>
<p>[0] <a href="http://standards.freedesktop.org/desktop-entry-spec/">http://standards.freedesktop.org/desktop-entry-spec/</a> </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01240">1240</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="a2c6ace340b03217a048f41644ca6794c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6ace340b03217a048f41644ca6794c">&#9670;&nbsp;</a></span>set_fullscreen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdg_toplevel_t::set_fullscreen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwayland_1_1output__t.html">output_t</a>&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the window as fullscreen on an output </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Make the surface fullscreen.</p>
<p>After requesting that the surface should be fullscreened, the compositor will respond by emitting a configure event. Whether the client is actually put into a fullscreen state is subject to compositor policies. The client must also acknowledge the configure when committing the new content (see ack_configure).</p>
<p>The output passed by the request indicates the client's preference as to which display it should be set fullscreen on. If this value is NULL, it's up to the compositor to choose which display will be used to map this surface.</p>
<p>If the surface doesn't cover the whole output, the compositor will position the surface in the center of the output and compensate with with border fill covering the rest of the output. The content of the border fill is undefined, but should be assumed to be in some way that attempts to blend into the surrounding area (e.g. solid black).</p>
<p>If the fullscreened surface is not opaque, the compositor must make sure that other screen content not part of the same surface tree (made up of subsurfaces, popups or similarly coupled surfaces) are not visible below the fullscreened surface. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01280">1280</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="a608d327530e874ed666a0eff8d8fb259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608d327530e874ed666a0eff8d8fb259">&#9670;&nbsp;</a></span>set_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdg_toplevel_t::set_max_size </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the maximum size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">height</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Set a maximum size for the window.</p>
<p>The client can specify a maximum size so that the compositor does not try to configure the window beyond this size.</p>
<p>The width and height arguments are in window geometry coordinates. See xdg_surface.set_window_geometry.</p>
<p>Values set in this way are double-buffered. They will get applied on the next commit.</p>
<p>The compositor can use this information to allow or disallow different states like maximize or fullscreen and draw accurate animations.</p>
<p>Similarly, a tiling window manager may use this information to place and resize client windows in a more effective way.</p>
<p>The client should not rely on the compositor to obey the maximum size. The compositor may decide to ignore the values set by the client and request a larger size.</p>
<p>If never set, or a value of zero in the request, means that the client has no expected maximum size in the given dimension. As a result, a client wishing to reset the maximum size to an unspecified state can use zero for width and height in the request.</p>
<p>Requesting a maximum size to be smaller than the minimum size of a surface is illegal and will result in a protocol error.</p>
<p>The width and height must be greater than or equal to zero. Using strictly negative values for width and height will result in a protocol error. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01260">1260</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="a55d7485f59eeec328335d1fe86fca9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d7485f59eeec328335d1fe86fca9f4">&#9670;&nbsp;</a></span>set_maximized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdg_toplevel_t::set_maximized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>maximize the window </p>
<p>Maximize the surface.</p>
<p>After requesting that the surface should be maximized, the compositor will respond by emitting a configure event. Whether this configure actually sets the window maximized is subject to compositor policies. The client must then update its content, drawing in the configured state. The client must also acknowledge the configure when committing the new content (see ack_configure).</p>
<p>It is up to the compositor to decide how and where to maximize the surface, for example which output and what region of the screen should be used.</p>
<p>If the surface was already maximized, the compositor will still emit a configure event with the "maximized" state.</p>
<p>If the surface is in a fullscreen state, this request has no direct effect. It may alter the state the surface is returned to when unmaximized unless overridden by the compositor. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01270">1270</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="a539a675afe84f545ed9b05824e0a99e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539a675afe84f545ed9b05824e0a99e3">&#9670;&nbsp;</a></span>set_min_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdg_toplevel_t::set_min_size </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the minimum size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">height</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Set a minimum size for the window.</p>
<p>The client can specify a minimum size so that the compositor does not try to configure the window below this size.</p>
<p>The width and height arguments are in window geometry coordinates. See xdg_surface.set_window_geometry.</p>
<p>Values set in this way are double-buffered. They will get applied on the next commit.</p>
<p>The compositor can use this information to allow or disallow different states like maximize or fullscreen and draw accurate animations.</p>
<p>Similarly, a tiling window manager may use this information to place and resize client windows in a more effective way.</p>
<p>The client should not rely on the compositor to obey the minimum size. The compositor may decide to ignore the values set by the client and request a smaller size.</p>
<p>If never set, or a value of zero in the request, means that the client has no expected minimum size in the given dimension. As a result, a client wishing to reset the minimum size to an unspecified state can use zero for width and height in the request.</p>
<p>Requesting a minimum size to be larger than the maximum size of a surface is illegal and will result in a protocol error.</p>
<p>The width and height must be greater than or equal to zero. Using strictly negative values for width and height will result in a protocol error. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01265">1265</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="a7e2c02efb228b17f19e6d436ae523e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2c02efb228b17f19e6d436ae523e94">&#9670;&nbsp;</a></span>set_minimized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdg_toplevel_t::set_minimized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the window as minimized </p>
<p>Request that the compositor minimize your surface. There is no way to know if the surface is currently minimized, nor is there any way to unset minimization on this surface.</p>
<p>If you are looking to throttle redrawing when minimized, please instead use the wl_surface.frame event for this, as this will also work with live previews on windows in Alt-Tab, Expose or similar compositor features. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01290">1290</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="ab9b32e22ab7edb7e527effd7991be260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b32e22ab7edb7e527effd7991be260">&#9670;&nbsp;</a></span>set_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdg_toplevel_t::set_parent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwayland_1_1xdg__toplevel__t.html">xdg_toplevel_t</a>&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the parent of this surface </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Set the "parent" of this surface. This surface should be stacked above the parent surface and all other ancestor surfaces.</p>
<p>Parent windows should be set on dialogs, toolboxes, or other "auxiliary" surfaces, so that the parent is raised when the dialog is raised.</p>
<p>Setting a null parent for a child window removes any parent-child relationship for the child. Setting a null parent for a window which currently has no parent is a no-op.</p>
<p>If the parent is unmapped then its children are managed as though the parent of the now-unmapped parent has become the parent of this surface. If no parent exists for the now-unmapped parent then the children are managed as though they have no parent surface. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01230">1230</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="a2065bb6f0ba51f29fdf16b8168bb5958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2065bb6f0ba51f29fdf16b8168bb5958">&#9670;&nbsp;</a></span>set_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wayland::proxy_t::set_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a proxy to an event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The event queue that will handle this proxy</td></tr>
  </table>
  </dd>
</dl>
<p>Assign proxy to event queue. Events coming from proxy will be queued in queue instead of the display's main queue.</p>
<p>See also: <a class="el" href="classwayland_1_1display__t.html#a967a3e54ca3bffb6ba05abf44aef1840" title="Dispatch events in an event queue.">display_t::dispatch_queue()</a>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="proxy_wrapper_8cpp-example.html#a5">proxy_wrapper.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a45e4632d00f4b52b96c3706081d4d9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e4632d00f4b52b96c3706081d4d9bf">&#9670;&nbsp;</a></span>set_title()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdg_toplevel_t::set_title </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>title</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set surface title </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">title</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Set a short title for the surface.</p>
<p>This string may be used to identify the surface in a task bar, window list, or other user interface elements provided by the compositor.</p>
<p>The string must be encoded in UTF-8. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="egl_8cpp-example.html#a33">egl.cpp</a>, and <a class="el" href="shm_8cpp-example.html#a35">shm.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01235">1235</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="a2a937bcde98359c96b89a542ea572114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a937bcde98359c96b89a542ea572114">&#9670;&nbsp;</a></span>show_window_menu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdg_toplevel_t::show_window_menu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwayland_1_1seat__t.html">seat_t</a>&#160;</td>
          <td class="paramname"><em>seat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>show the window menu </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seat</td><td>the wl_seat of the user event </td></tr>
    <tr><td class="paramname">serial</td><td>the serial of the user event </td></tr>
    <tr><td class="paramname">x</td><td>the x position to pop up the window menu at </td></tr>
    <tr><td class="paramname">y</td><td>the y position to pop up the window menu at</td></tr>
  </table>
  </dd>
</dl>
<p>Clients implementing client-side decorations might want to show a context menu when right-clicking on the decorations, giving the user a menu that they can use to maximize or minimize the window.</p>
<p>This request asks the compositor to pop up such a window menu at the given position, relative to the local surface coordinates of the parent surface. There are no guarantees as to what menu items the window menu contains.</p>
<p>This request must be used in response to some sort of user action like a button press, key press, or touch down event. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01245">1245</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="af3836376d6911ff739218f2d7e462b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3836376d6911ff739218f2d7e462b46">&#9670;&nbsp;</a></span>unset_fullscreen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdg_toplevel_t::unset_fullscreen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unset the window as fullscreen </p>
<p>Make the surface no longer fullscreen.</p>
<p>After requesting that the surface should be unfullscreened, the compositor will respond by emitting a configure event. Whether this actually removes the fullscreen state of the client is subject to compositor policies.</p>
<p>Making a surface unfullscreen sets states for the surface based on the following: the state(s) it may have had before becoming fullscreen any state(s) decided by the compositor any state(s) requested by the client while the surface was fullscreen</p>
<p>The compositor may include the previous window geometry dimensions in the configure event, if applicable.</p>
<p>The client must also acknowledge the configure when committing the new content (see ack_configure). </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01285">1285</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="aff3a7b00545369856391a56faebb10b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3a7b00545369856391a56faebb10b6">&#9670;&nbsp;</a></span>unset_maximized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdg_toplevel_t::unset_maximized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unmaximize the window </p>
<p>Unmaximize the surface.</p>
<p>After requesting that the surface should be unmaximized, the compositor will respond by emitting a configure event. Whether this actually un-maximizes the window is subject to compositor policies. If available and applicable, the compositor will include the window geometry dimensions the window had prior to being maximized in the configure event. The client must then update its content, drawing it in the configured state. The client must also acknowledge the configure when committing the new content (see ack_configure).</p>
<p>It is up to the compositor to position the surface after it was unmaximized; usually the position the surface had before maximizing, if applicable.</p>
<p>If the surface was already not maximized, the compositor will still emit a configure event without the "maximized" state.</p>
<p>If the surface is in a fullscreen state, this request has no direct effect. It may alter the state the surface is returned to when unmaximized unless overridden by the compositor. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01275">1275</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aae85a7f08f5c9e653f0f50cb00e38ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae85a7f08f5c9e653f0f50cb00e38ac1">&#9670;&nbsp;</a></span>move_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_toplevel_t::move_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a81a661a96ec48e08fd3b58a5f604ad55">move</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01297">1297</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<a id="a2f3e48f7ab2117ded9f776d745aa3c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3e48f7ab2117ded9f776d745aa3c6f">&#9670;&nbsp;</a></span>resize_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_toplevel_t::resize_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#af5102efd2c01ad56eb5811887a7df1e6">resize</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01340">1340</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<a id="a71ca71b4589293fa6686802a7be2fcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ca71b4589293fa6686802a7be2fcc5">&#9670;&nbsp;</a></span>set_app_id_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_toplevel_t::set_app_id_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a795aaf0eb3f578ae2eea5b163e7d2fc1">set_app_id</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01244">1244</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<a id="a5f3a43e8f977f5655f82f5de7ec08c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3a43e8f977f5655f82f5de7ec08c86">&#9670;&nbsp;</a></span>set_fullscreen_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_toplevel_t::set_fullscreen_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a2c6ace340b03217a048f41644ca6794c">set_fullscreen</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01526">1526</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<a id="a306252a421df25c6d2a828959c701a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306252a421df25c6d2a828959c701a4a">&#9670;&nbsp;</a></span>set_max_size_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_toplevel_t::set_max_size_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a608d327530e874ed666a0eff8d8fb259">set_max_size</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01386">1386</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<a id="ab6aea27211801288f3fc205c4b2891e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6aea27211801288f3fc205c4b2891e2">&#9670;&nbsp;</a></span>set_maximized_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_toplevel_t::set_maximized_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a55d7485f59eeec328335d1fe86fca9f4">set_maximized</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01461">1461</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<a id="a64d426a247cb109dcb4ea57750d57614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d426a247cb109dcb4ea57750d57614">&#9670;&nbsp;</a></span>set_min_size_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_toplevel_t::set_min_size_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a539a675afe84f545ed9b05824e0a99e3">set_min_size</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01432">1432</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<a id="a78c885daa3622f76269c956b395831b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c885daa3622f76269c956b395831b8">&#9670;&nbsp;</a></span>set_minimized_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_toplevel_t::set_minimized_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a7e2c02efb228b17f19e6d436ae523e94">set_minimized</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01571">1571</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<a id="af046c8fd5dc6ca06ae5448e6b99a15f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af046c8fd5dc6ca06ae5448e6b99a15f2">&#9670;&nbsp;</a></span>set_parent_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_toplevel_t::set_parent_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#ab9b32e22ab7edb7e527effd7991be260">set_parent</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01192">1192</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<a id="acb8144c4e9d92be847d49a214d7b7f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8144c4e9d92be847d49a214d7b7f3f">&#9670;&nbsp;</a></span>set_title_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_toplevel_t::set_title_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a45e4632d00f4b52b96c3706081d4d9bf">set_title</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01210">1210</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<a id="a76cbd4703095deafbf6d4c6d71f6d27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cbd4703095deafbf6d4c6d71f6d27d">&#9670;&nbsp;</a></span>show_window_menu_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_toplevel_t::show_window_menu_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#a2a937bcde98359c96b89a542ea572114">show_window_menu</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01269">1269</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<a id="aba10a7706e227c7412b496896a414a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba10a7706e227c7412b496896a414a41">&#9670;&nbsp;</a></span>unset_fullscreen_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_toplevel_t::unset_fullscreen_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#af3836376d6911ff739218f2d7e462b46">unset_fullscreen</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01553">1553</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<a id="a378646c9f2f2c65e44f62cfb23df6d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378646c9f2f2c65e44f62cfb23df6d48">&#9670;&nbsp;</a></span>unset_maximized_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_toplevel_t::unset_maximized_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__toplevel__t.html#aff3a7b00545369856391a56faebb10b6">unset_maximized</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01492">1492</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>build/<a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a></li>
<li>build/<a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>wayland</b></li><li class="navelem"><a class="el" href="classwayland_1_1xdg__toplevel__t.html">xdg_toplevel_t</a></li>
    <li class="footer">Generated on Tue Oct 8 2019 20:07:40 for Wayland++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
