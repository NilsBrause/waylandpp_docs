<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wayland++: wayland::xdg_surface_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wayland++
   &#160;<span id="projectnumber">0.2.6</span>
   </div>
   <div id="projectbrief">C++ Bindings for Wayland</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classwayland_1_1xdg__surface__t.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classwayland_1_1xdg__surface__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">wayland::xdg_surface_t Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>desktop user interface surface base interface  
 <a href="classwayland_1_1xdg__surface__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for wayland::xdg_surface_t:</div>
<div class="dyncontent">
<div class="center"><img src="classwayland_1_1xdg__surface__t__inherit__graph.png" border="0" usemap="#wayland_1_1xdg__surface__t_inherit__map" alt="Inheritance graph"/></div>
<map name="wayland_1_1xdg__surface__t_inherit__map" id="wayland_1_1xdg__surface__t_inherit__map">
<area shape="rect" title="desktop user interface surface base interface" alt="" coords="5,80,181,107"/>
<area shape="rect" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side." alt="" coords="26,5,161,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for wayland::xdg_surface_t:</div>
<div class="dyncontent">
<div class="center"><img src="classwayland_1_1xdg__surface__t__coll__graph.png" border="0" usemap="#wayland_1_1xdg__surface__t_coll__map" alt="Collaboration graph"/></div>
<map name="wayland_1_1xdg__surface__t_coll__map" id="wayland_1_1xdg__surface__t_coll__map">
<area shape="rect" title="desktop user interface surface base interface" alt="" coords="5,80,181,107"/>
<area shape="rect" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side." alt="" coords="26,5,161,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afc44f0d53890db6bd32d9b2f0c6994e9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9">wrapper_type</a> { <a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9ac00f0c4675b91fb8b918e4079a0b1bac">wrapper_type::standard</a>, 
<a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9aebf78b512222fe4dcd14e7d5060a15b0">wrapper_type::display</a>, 
<a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9a684a72e08f24f55b1138edd5a7c2b53e">wrapper_type::foreign</a>, 
<a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9ae6cc1490287e90290ddd4e0b9efeb6d5">wrapper_type::proxy_wrapper</a>
 }</td></tr>
<tr class="separator:afc44f0d53890db6bd32d9b2f0c6994e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a41277bb639cb295bcad92a0e7fbbf99a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwayland_1_1xdg__toplevel__t.html">xdg_toplevel_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__surface__t.html#a41277bb639cb295bcad92a0e7fbbf99a">get_toplevel</a> ()</td></tr>
<tr class="memdesc:a41277bb639cb295bcad92a0e7fbbf99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign the xdg_toplevel surface role  <a href="classwayland_1_1xdg__surface__t.html#a41277bb639cb295bcad92a0e7fbbf99a">More...</a><br /></td></tr>
<tr class="separator:a41277bb639cb295bcad92a0e7fbbf99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1aa74dddbde84b9bc3ccd57b03c3651"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwayland_1_1xdg__popup__t.html">xdg_popup_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__surface__t.html#ac1aa74dddbde84b9bc3ccd57b03c3651">get_popup</a> (<a class="el" href="classwayland_1_1xdg__surface__t.html">xdg_surface_t</a> parent, <a class="el" href="classwayland_1_1xdg__positioner__t.html">xdg_positioner_t</a> positioner)</td></tr>
<tr class="memdesc:ac1aa74dddbde84b9bc3ccd57b03c3651"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign the xdg_popup surface role  <a href="classwayland_1_1xdg__surface__t.html#ac1aa74dddbde84b9bc3ccd57b03c3651">More...</a><br /></td></tr>
<tr class="separator:ac1aa74dddbde84b9bc3ccd57b03c3651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e190c79c1c24e72cca6ccf2ee84da8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__surface__t.html#ae9e190c79c1c24e72cca6ccf2ee84da8">set_window_geometry</a> (int32_t x, int32_t y, int32_t width, int32_t height)</td></tr>
<tr class="memdesc:ae9e190c79c1c24e72cca6ccf2ee84da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the new window geometry  <a href="classwayland_1_1xdg__surface__t.html#ae9e190c79c1c24e72cca6ccf2ee84da8">More...</a><br /></td></tr>
<tr class="separator:ae9e190c79c1c24e72cca6ccf2ee84da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58704c4d6d094deb1c44bdf98f0b1b2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__surface__t.html#a58704c4d6d094deb1c44bdf98f0b1b2a">ack_configure</a> (uint32_t serial)</td></tr>
<tr class="memdesc:a58704c4d6d094deb1c44bdf98f0b1b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ack a configure event  <a href="classwayland_1_1xdg__surface__t.html#a58704c4d6d094deb1c44bdf98f0b1b2a">More...</a><br /></td></tr>
<tr class="separator:a58704c4d6d094deb1c44bdf98f0b1b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4010349958fdf405cc96129e26b02fb1"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(uint32_t)&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__surface__t.html#a4010349958fdf405cc96129e26b02fb1">on_configure</a> ()</td></tr>
<tr class="memdesc:a4010349958fdf405cc96129e26b02fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">suggest a surface change  <a href="classwayland_1_1xdg__surface__t.html#a4010349958fdf405cc96129e26b02fb1">More...</a><br /></td></tr>
<tr class="separator:a4010349958fdf405cc96129e26b02fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273d7fd6604b65d4c4d24747b639a263"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a273d7fd6604b65d4c4d24747b639a263">get_id</a> () const</td></tr>
<tr class="memdesc:a273d7fd6604b65d4c4d24747b639a263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of a proxy object.  <a href="classwayland_1_1proxy__t.html#a273d7fd6604b65d4c4d24747b639a263">More...</a><br /></td></tr>
<tr class="separator:a273d7fd6604b65d4c4d24747b639a263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a77c6eab2f2eb4cfcca56be8a780d3e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a8a77c6eab2f2eb4cfcca56be8a780d3e">get_class</a> () const</td></tr>
<tr class="memdesc:a8a77c6eab2f2eb4cfcca56be8a780d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interface name (class) of a proxy object.  <a href="classwayland_1_1proxy__t.html#a8a77c6eab2f2eb4cfcca56be8a780d3e">More...</a><br /></td></tr>
<tr class="separator:a8a77c6eab2f2eb4cfcca56be8a780d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59444022b75257f6b27d2c464c371779"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a59444022b75257f6b27d2c464c371779">get_version</a> () const</td></tr>
<tr class="memdesc:a59444022b75257f6b27d2c464c371779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the protocol object version of a proxy object.  <a href="classwayland_1_1proxy__t.html#a59444022b75257f6b27d2c464c371779">More...</a><br /></td></tr>
<tr class="separator:a59444022b75257f6b27d2c464c371779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65253c6ac727496735c0dc42a9fd1568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9">wrapper_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a65253c6ac727496735c0dc42a9fd1568">get_wrapper_type</a> () const</td></tr>
<tr class="memdesc:a65253c6ac727496735c0dc42a9fd1568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of a proxy object.  <a href="classwayland_1_1proxy__t.html#a65253c6ac727496735c0dc42a9fd1568">More...</a><br /></td></tr>
<tr class="separator:a65253c6ac727496735c0dc42a9fd1568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2065bb6f0ba51f29fdf16b8168bb5958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a2065bb6f0ba51f29fdf16b8168bb5958">set_queue</a> (<a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a> queue)</td></tr>
<tr class="memdesc:a2065bb6f0ba51f29fdf16b8168bb5958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a proxy to an event queue.  <a href="classwayland_1_1proxy__t.html#a2065bb6f0ba51f29fdf16b8168bb5958">More...</a><br /></td></tr>
<tr class="separator:a2065bb6f0ba51f29fdf16b8168bb5958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9f256a9bfaed12ad36a357cc22df5e"><td class="memItemLeft" align="right" valign="top">wl_proxy *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a6a9f256a9bfaed12ad36a357cc22df5e">c_ptr</a> () const</td></tr>
<tr class="memdesc:a6a9f256a9bfaed12ad36a357cc22df5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the underlying C struct.  <a href="classwayland_1_1proxy__t.html#a6a9f256a9bfaed12ad36a357cc22df5e">More...</a><br /></td></tr>
<tr class="separator:a6a9f256a9bfaed12ad36a357cc22df5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c596640d7469447cb0b91dc9c8c22b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a0c596640d7469447cb0b91dc9c8c22b2">proxy_has_object</a> () const</td></tr>
<tr class="memdesc:a0c596640d7469447cb0b91dc9c8c22b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this wrapper actually wraps an object.  <a href="classwayland_1_1proxy__t.html#a0c596640d7469447cb0b91dc9c8c22b2">More...</a><br /></td></tr>
<tr class="separator:a0c596640d7469447cb0b91dc9c8c22b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa72a9121fa69ccfad6e9eff8740b5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#aafa72a9121fa69ccfad6e9eff8740b5e">operator bool</a> () const</td></tr>
<tr class="memdesc:aafa72a9121fa69ccfad6e9eff8740b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this wrapper actually wraps an object.  <a href="classwayland_1_1proxy__t.html#aafa72a9121fa69ccfad6e9eff8740b5e">More...</a><br /></td></tr>
<tr class="separator:aafa72a9121fa69ccfad6e9eff8740b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc433db4597e77caccb07f99b26a259"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a3dc433db4597e77caccb07f99b26a259">operator==</a> (const <a class="el" href="classwayland_1_1proxy__t.html">proxy_t</a> &amp;right) const</td></tr>
<tr class="memdesc:a3dc433db4597e77caccb07f99b26a259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two wrappers refer to the same object.  <a href="classwayland_1_1proxy__t.html#a3dc433db4597e77caccb07f99b26a259">More...</a><br /></td></tr>
<tr class="separator:a3dc433db4597e77caccb07f99b26a259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac460e26f384624eb96647d533314240a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#ac460e26f384624eb96647d533314240a">operator!=</a> (const <a class="el" href="classwayland_1_1proxy__t.html">proxy_t</a> &amp;right) const</td></tr>
<tr class="memdesc:ac460e26f384624eb96647d533314240a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two wrappers refer to different objects.  <a href="classwayland_1_1proxy__t.html#ac460e26f384624eb96647d533314240a">More...</a><br /></td></tr>
<tr class="separator:ac460e26f384624eb96647d533314240a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af69af8f839a5a5ea354e52705e9a43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a0af69af8f839a5a5ea354e52705e9a43">proxy_release</a> ()</td></tr>
<tr class="memdesc:a0af69af8f839a5a5ea354e52705e9a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the wrapped object (if any), making this an empty wrapper.  <a href="classwayland_1_1proxy__t.html#a0af69af8f839a5a5ea354e52705e9a43">More...</a><br /></td></tr>
<tr class="separator:a0af69af8f839a5a5ea354e52705e9a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab175c77ec3bcc0633535c22621d549a5"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__surface__t.html#ab175c77ec3bcc0633535c22621d549a5">get_toplevel_since_version</a> = 1</td></tr>
<tr class="memdesc:ab175c77ec3bcc0633535c22621d549a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__surface__t.html#a41277bb639cb295bcad92a0e7fbbf99a">get_toplevel</a> function.  <a href="classwayland_1_1xdg__surface__t.html#ab175c77ec3bcc0633535c22621d549a5">More...</a><br /></td></tr>
<tr class="separator:ab175c77ec3bcc0633535c22621d549a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356311922a0b150ca305bbfdd57addc7"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__surface__t.html#a356311922a0b150ca305bbfdd57addc7">get_popup_since_version</a> = 1</td></tr>
<tr class="memdesc:a356311922a0b150ca305bbfdd57addc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__surface__t.html#ac1aa74dddbde84b9bc3ccd57b03c3651">get_popup</a> function.  <a href="classwayland_1_1xdg__surface__t.html#a356311922a0b150ca305bbfdd57addc7">More...</a><br /></td></tr>
<tr class="separator:a356311922a0b150ca305bbfdd57addc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c7a4493f5f8eb5506b802560c431a7"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__surface__t.html#a05c7a4493f5f8eb5506b802560c431a7">set_window_geometry_since_version</a> = 1</td></tr>
<tr class="memdesc:a05c7a4493f5f8eb5506b802560c431a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__surface__t.html#ae9e190c79c1c24e72cca6ccf2ee84da8">set_window_geometry</a> function.  <a href="classwayland_1_1xdg__surface__t.html#a05c7a4493f5f8eb5506b802560c431a7">More...</a><br /></td></tr>
<tr class="separator:a05c7a4493f5f8eb5506b802560c431a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d25373bc418222b1b8d776cf7fa11f4"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1xdg__surface__t.html#a7d25373bc418222b1b8d776cf7fa11f4">ack_configure_since_version</a> = 1</td></tr>
<tr class="memdesc:a7d25373bc418222b1b8d776cf7fa11f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__surface__t.html#a58704c4d6d094deb1c44bdf98f0b1b2a">ack_configure</a> function.  <a href="classwayland_1_1xdg__surface__t.html#a7d25373bc418222b1b8d776cf7fa11f4">More...</a><br /></td></tr>
<tr class="separator:a7d25373bc418222b1b8d776cf7fa11f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>desktop user interface surface base interface </p>
<p>An interface that may be implemented by a wl_surface, for implementations that provide a desktop-style user interface.</p>
<p>It provides a base set of functionality required to construct user interface elements requiring management by the compositor, such as toplevel windows, menus, etc. The types of functionality are split into xdg_surface roles.</p>
<p>Creating an xdg_surface does not set the role for a wl_surface. In order to map an xdg_surface, the client must create a role-specific object using, e.g., get_toplevel, get_popup. The wl_surface for any given xdg_surface can have at most one role, and may not be assigned any role not based on xdg_surface.</p>
<p>A role must be assigned before any other requests are made to the xdg_surface object.</p>
<p>The client must call wl_surface.commit on the corresponding wl_surface for the xdg_surface state to take effect.</p>
<p>Creating an xdg_surface from a wl_surface which has a buffer attached or committed is a client error, and any attempts by a client to attach or manipulate a buffer prior to the first xdg_surface.configure call must also be treated as errors.</p>
<p>Mapping an xdg_surface-based role surface is defined as making it possible for the surface to be shown by the compositor. Note that a mapped surface is not guaranteed to be visible once it is mapped.</p>
<p>For an xdg_surface to be mapped by the compositor, the following conditions must be met: (1) the client has assigned an xdg_surface-based role to the surface (2) the client has set and committed the xdg_surface state and the role-dependent state to the surface (3) the client has committed a buffer to the surface</p>
<p>A newly-unmapped surface is considered to have met condition (1) out of the 3 required conditions for mapping a surface if its role surface has not been destroyed. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="egl_8cpp-example.html#_a9">egl.cpp</a>, and <a class="el" href="shm_8cpp-example.html#_a9">shm.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l00959">959</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="afc44f0d53890db6bd32d9b2f0c6994e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc44f0d53890db6bd32d9b2f0c6994e9">&#9670;&nbsp;</a></span>wrapper_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9">wayland::proxy_t::wrapper_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Underlying wl_proxy type and properties of a <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> that affect construction, destruction, and event handling </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afc44f0d53890db6bd32d9b2f0c6994e9ac00f0c4675b91fb8b918e4079a0b1bac"></a>standard&#160;</td><td class="fielddoc"><p>C pointer is a standard type compatible with wl_proxy*. Events are dispatched and it is destructed when the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is destructed. User data is set. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc44f0d53890db6bd32d9b2f0c6994e9aebf78b512222fe4dcd14e7d5060a15b0"></a>display&#160;</td><td class="fielddoc"><p>C pointer is a wl_display*. No events are dispatched, wl_display_disconnect is called when the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is destructed. User data is set. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc44f0d53890db6bd32d9b2f0c6994e9a684a72e08f24f55b1138edd5a7c2b53e"></a>foreign&#160;</td><td class="fielddoc"><p>C pointer is a standard type compatible with wl_proxy*, but another library owns it and it should not be touched in a way that could affect the operation of the other library. No events are dispatched, wl_proxy_destroy is not called when the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is destructed, user data is not touched. Consequently, there is no reference counting for the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a>. Lifetime of such wrappers should preferably be short to minimize the chance that the owning library decides to destroy the wl_proxy. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc44f0d53890db6bd32d9b2f0c6994e9ae6cc1490287e90290ddd4e0b9efeb6d5"></a>proxy_wrapper&#160;</td><td class="fielddoc"><p>C pointer is a wl_proxy* that was constructed with wl_proxy_create_wrapper. No events are dispatched, wl_proxy_wrapper_destroy is called when the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is destroyed. Reference counting is active. A reference to the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> creating this proxy wrapper is held to extend its lifetime until after the proxy wrapper is destroyed. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="wayland-client_8hpp_source.html#l00105">105</a> of file <a class="el" href="wayland-client_8hpp_source.html">wayland-client.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a58704c4d6d094deb1c44bdf98f0b1b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58704c4d6d094deb1c44bdf98f0b1b2a">&#9670;&nbsp;</a></span>ack_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdg_surface_t::ack_configure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>serial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ack a configure event </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serial</td><td>the serial from the configure event</td></tr>
  </table>
  </dd>
</dl>
<p>When a configure event is received, if a client commits the surface in response to the configure event, then the client must make an ack_configure request sometime before the commit request, passing along the serial of the configure event.</p>
<p>For instance, for toplevel surfaces the compositor might use this information to move a surface to the top left only when the client has drawn itself for the maximized or fullscreen state.</p>
<p>If the client receives multiple configure events before it can respond to one, it only has to ack the last configure event.</p>
<p>A client is not required to commit immediately after sending an ack_configure request - it may even ack_configure several times before its next surface commit.</p>
<p>A client may send multiple ack_configure requests before committing, but only the last request sent before a commit indicates which configure event the client really is responding to. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="egl_8cpp-example.html#a31">egl.cpp</a>, and <a class="el" href="shm_8cpp-example.html#a33">shm.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01156">1156</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="a6a9f256a9bfaed12ad36a357cc22df5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9f256a9bfaed12ad36a357cc22df5e">&#9670;&nbsp;</a></span>c_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wl_proxy* wayland::proxy_t::c_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the underlying C struct. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying wl_proxy wrapped by this <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> if it exists, otherwise an exception is thrown </dd></dl>

</div>
</div>
<a id="a8a77c6eab2f2eb4cfcca56be8a780d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a77c6eab2f2eb4cfcca56be8a780d3e">&#9670;&nbsp;</a></span>get_class()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string wayland::proxy_t::get_class </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the interface name (class) of a proxy object. </p>
<dl class="section return"><dt>Returns</dt><dd>The interface name of the object associated with the proxy </dd></dl>

</div>
</div>
<a id="a273d7fd6604b65d4c4d24747b639a263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273d7fd6604b65d4c4d24747b639a263">&#9670;&nbsp;</a></span>get_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t wayland::proxy_t::get_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the id of a proxy object. </p>
<dl class="section return"><dt>Returns</dt><dd>The id the object associated with the proxy </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="dump_8cpp-example.html#a6">dump.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac1aa74dddbde84b9bc3ccd57b03c3651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1aa74dddbde84b9bc3ccd57b03c3651">&#9670;&nbsp;</a></span>get_popup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwayland_1_1xdg__popup__t.html">xdg_popup_t</a> xdg_surface_t::get_popup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwayland_1_1xdg__surface__t.html">xdg_surface_t</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwayland_1_1xdg__positioner__t.html">xdg_positioner_t</a>&#160;</td>
          <td class="paramname"><em>positioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assign the xdg_popup surface role </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td></td></tr>
    <tr><td class="paramname">positioner</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>This creates an xdg_popup object for the given xdg_surface and gives the associated wl_surface the xdg_popup role.</p>
<p>If null is passed as a parent, a parent surface must be specified using some other protocol, before committing the initial state.</p>
<p>See the documentation of xdg_popup for more details about what an xdg_popup is and how it is used. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01145">1145</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="a41277bb639cb295bcad92a0e7fbbf99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41277bb639cb295bcad92a0e7fbbf99a">&#9670;&nbsp;</a></span>get_toplevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwayland_1_1xdg__toplevel__t.html">xdg_toplevel_t</a> xdg_surface_t::get_toplevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assign the xdg_toplevel surface role </p>
<p>This creates an xdg_toplevel object for the given xdg_surface and gives the associated wl_surface the xdg_toplevel role.</p>
<p>See the documentation of xdg_toplevel for more details about what an xdg_toplevel is and how it is used. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="egl_8cpp-example.html#a32">egl.cpp</a>, and <a class="el" href="shm_8cpp-example.html#a34">shm.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01139">1139</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="a59444022b75257f6b27d2c464c371779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59444022b75257f6b27d2c464c371779">&#9670;&nbsp;</a></span>get_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t wayland::proxy_t::get_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the protocol object version of a proxy object. </p>
<p>Gets the protocol object version of a proxy object, or 0 if the proxy was created with unversioned API.</p>
<p>A returned value of 0 means that no version information is available, so the caller must make safe assumptions about the object's real version.</p>
<p><a class="el" href="classwayland_1_1display__t.html">display_t</a> will always return version 0.</p>
<dl class="section return"><dt>Returns</dt><dd>The protocol object version of the proxy or 0 </dd></dl>

</div>
</div>
<a id="a65253c6ac727496735c0dc42a9fd1568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65253c6ac727496735c0dc42a9fd1568">&#9670;&nbsp;</a></span>get_wrapper_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9">wrapper_type</a> wayland::proxy_t::get_wrapper_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of a proxy object. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client_8hpp_source.html#l00288">288</a> of file <a class="el" href="wayland-client_8hpp_source.html">wayland-client.hpp</a>.</p>

</div>
</div>
<a id="a4010349958fdf405cc96129e26b02fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4010349958fdf405cc96129e26b02fb1">&#9670;&nbsp;</a></span>on_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(uint32_t)&gt; &amp; xdg_surface_t::on_configure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>suggest a surface change </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serial</td><td>serial of the configure event</td></tr>
  </table>
  </dd>
</dl>
<p>The configure event marks the end of a configure sequence. A configure sequence is a set of one or more events configuring the state of the xdg_surface, including the final xdg_surface.configure event.</p>
<p>Where applicable, xdg_surface surface roles will during a configure sequence extend this event as a latched state sent as events before the xdg_surface.configure event. Such events should be considered to make up a set of atomically applied configuration states, where the xdg_surface.configure commits the accumulated state.</p>
<p>Clients should arrange their surface for the new states, and then send an ack_configure request with the serial sent in this configure event at some point before committing the new surface.</p>
<p>If the client receives multiple configure events before it can respond to one, it is free to discard all but the last event it received. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="egl_8cpp-example.html#a30">egl.cpp</a>, and <a class="el" href="shm_8cpp-example.html#a32">shm.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01161">1161</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<a id="aafa72a9121fa69ccfad6e9eff8740b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa72a9121fa69ccfad6e9eff8740b5e">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wayland::proxy_t::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this wrapper actually wraps an object. </p>
<dl class="section return"><dt>Returns</dt><dd>true if there is an underlying object, false if this wrapper is empty </dd></dl>

</div>
</div>
<a id="ac460e26f384624eb96647d533314240a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac460e26f384624eb96647d533314240a">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wayland::proxy_t::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwayland_1_1proxy__t.html">proxy_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether two wrappers refer to different objects. </p>

</div>
</div>
<a id="a3dc433db4597e77caccb07f99b26a259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc433db4597e77caccb07f99b26a259">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wayland::proxy_t::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwayland_1_1proxy__t.html">proxy_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether two wrappers refer to the same object. </p>

</div>
</div>
<a id="a0c596640d7469447cb0b91dc9c8c22b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c596640d7469447cb0b91dc9c8c22b2">&#9670;&nbsp;</a></span>proxy_has_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wayland::proxy_t::proxy_has_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this wrapper actually wraps an object. </p>
<dl class="section return"><dt>Returns</dt><dd>true if there is an underlying object, false if this wrapper is empty </dd></dl>

</div>
</div>
<a id="a0af69af8f839a5a5ea354e52705e9a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af69af8f839a5a5ea354e52705e9a43">&#9670;&nbsp;</a></span>proxy_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wayland::proxy_t::proxy_release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the wrapped object (if any), making this an empty wrapper. </p>
<p>Note that <a class="el" href="classwayland_1_1display__t.html" title="Represents a connection to the compositor and acts as a proxy to the display singleton object.">display_t</a> instances cannot be released this way. Attempts to do so are ignored. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="foreign_display_8cpp-example.html#a1">foreign_display.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2065bb6f0ba51f29fdf16b8168bb5958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2065bb6f0ba51f29fdf16b8168bb5958">&#9670;&nbsp;</a></span>set_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wayland::proxy_t::set_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a proxy to an event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The event queue that will handle this proxy</td></tr>
  </table>
  </dd>
</dl>
<p>Assign proxy to event queue. Events coming from proxy will be queued in queue instead of the display's main queue.</p>
<p>See also: <a class="el" href="classwayland_1_1display__t.html#a967a3e54ca3bffb6ba05abf44aef1840" title="Dispatch events in an event queue.">display_t::dispatch_queue()</a>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="proxy_wrapper_8cpp-example.html#a5">proxy_wrapper.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae9e190c79c1c24e72cca6ccf2ee84da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e190c79c1c24e72cca6ccf2ee84da8">&#9670;&nbsp;</a></span>set_window_geometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdg_surface_t::set_window_geometry </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the new window geometry </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">height</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>The window geometry of a surface is its "visible bounds" from the user's perspective. Client-side decorations often have invisible portions like drop-shadows which should be ignored for the purposes of aligning, placing and constraining windows.</p>
<p>The window geometry is double buffered, and will be applied at the time wl_surface.commit of the corresponding wl_surface is called.</p>
<p>When maintaining a position, the compositor should treat the (x, y) coordinate of the window geometry as the top left corner of the window. A client changing the (x, y) window geometry coordinate should in general not alter the position of the window.</p>
<p>Once the window geometry of the surface is set, it is not possible to unset it, and it will remain the same until set_window_geometry is called again, even if a new subsurface or buffer is attached.</p>
<p>If never set, the value is the full bounds of the surface, including any subsurfaces. This updates dynamically on every commit. This unset is meant for extremely simple clients.</p>
<p>The arguments are given in the surface-local coordinate space of the wl_surface associated with this xdg_surface.</p>
<p>The width and height must be greater than zero. Setting an invalid size will raise an error. When applied, the effective window geometry will be the set window geometry clamped to the bounding rectangle of the combined geometry of the surface of the xdg_surface and the associated subsurfaces. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8cpp_source.html#l01151">1151</a> of file <a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7d25373bc418222b1b8d776cf7fa11f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d25373bc418222b1b8d776cf7fa11f4">&#9670;&nbsp;</a></span>ack_configure_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_surface_t::ack_configure_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__surface__t.html#a58704c4d6d094deb1c44bdf98f0b1b2a">ack_configure</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01088">1088</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<a id="a356311922a0b150ca305bbfdd57addc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356311922a0b150ca305bbfdd57addc7">&#9670;&nbsp;</a></span>get_popup_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_surface_t::get_popup_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__surface__t.html#ac1aa74dddbde84b9bc3ccd57b03c3651">get_popup</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01015">1015</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<a id="ab175c77ec3bcc0633535c22621d549a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab175c77ec3bcc0633535c22621d549a5">&#9670;&nbsp;</a></span>get_toplevel_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_surface_t::get_toplevel_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__surface__t.html#a41277bb639cb295bcad92a0e7fbbf99a">get_toplevel</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l00995">995</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<a id="a05c7a4493f5f8eb5506b802560c431a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c7a4493f5f8eb5506b802560c431a7">&#9670;&nbsp;</a></span>set_window_geometry_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::xdg_surface_t::set_window_geometry_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1xdg__surface__t.html#ae9e190c79c1c24e72cca6ccf2ee84da8">set_window_geometry</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol-extra_8hpp_source.html#l01058">1058</a> of file <a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>build/<a class="el" href="wayland-client-protocol-extra_8hpp_source.html">wayland-client-protocol-extra.hpp</a></li>
<li>build/<a class="el" href="wayland-client-protocol-extra_8cpp_source.html">wayland-client-protocol-extra.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>wayland</b></li><li class="navelem"><a class="el" href="classwayland_1_1xdg__surface__t.html">xdg_surface_t</a></li>
    <li class="footer">Generated on Tue Oct 8 2019 20:07:40 for Wayland++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
