<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wayland++: wayland::pointer_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wayland++
   &#160;<span id="projectnumber">0.2.6</span>
   </div>
   <div id="projectbrief">C++ Bindings for Wayland</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classwayland_1_1pointer__t.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classwayland_1_1pointer__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">wayland::pointer_t Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>pointer input device  
 <a href="classwayland_1_1pointer__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="wayland-client-protocol_8hpp_source.html">wayland-client-protocol.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for wayland::pointer_t:</div>
<div class="dyncontent">
<div class="center"><img src="classwayland_1_1pointer__t__inherit__graph.png" border="0" usemap="#wayland_1_1pointer__t_inherit__map" alt="Inheritance graph"/></div>
<map name="wayland_1_1pointer__t_inherit__map" id="wayland_1_1pointer__t_inherit__map">
<area shape="rect" title="pointer input device" alt="" coords="5,80,148,107"/>
<area shape="rect" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side." alt="" coords="9,5,144,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for wayland::pointer_t:</div>
<div class="dyncontent">
<div class="center"><img src="classwayland_1_1pointer__t__coll__graph.png" border="0" usemap="#wayland_1_1pointer__t_coll__map" alt="Collaboration graph"/></div>
<map name="wayland_1_1pointer__t_coll__map" id="wayland_1_1pointer__t_coll__map">
<area shape="rect" title="pointer input device" alt="" coords="5,80,148,107"/>
<area shape="rect" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side." alt="" coords="9,5,144,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afc44f0d53890db6bd32d9b2f0c6994e9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9">wrapper_type</a> { <a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9ac00f0c4675b91fb8b918e4079a0b1bac">wrapper_type::standard</a>, 
<a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9aebf78b512222fe4dcd14e7d5060a15b0">wrapper_type::display</a>, 
<a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9a684a72e08f24f55b1138edd5a7c2b53e">wrapper_type::foreign</a>, 
<a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9ae6cc1490287e90290ddd4e0b9efeb6d5">wrapper_type::proxy_wrapper</a>
 }</td></tr>
<tr class="separator:afc44f0d53890db6bd32d9b2f0c6994e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5303d32f8043cd58697b854b72ba93d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1pointer__t.html#a5303d32f8043cd58697b854b72ba93d5">set_cursor</a> (uint32_t serial, <a class="el" href="classwayland_1_1surface__t.html">surface_t</a> surface, int32_t hotspot_x, int32_t hotspot_y)</td></tr>
<tr class="memdesc:a5303d32f8043cd58697b854b72ba93d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the pointer surface  <a href="classwayland_1_1pointer__t.html#a5303d32f8043cd58697b854b72ba93d5">More...</a><br /></td></tr>
<tr class="separator:a5303d32f8043cd58697b854b72ba93d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666e1b16dd64813a1b455a3ea83b6b16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1pointer__t.html#a666e1b16dd64813a1b455a3ea83b6b16">release</a> ()</td></tr>
<tr class="memdesc:a666e1b16dd64813a1b455a3ea83b6b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">release the pointer object  <a href="classwayland_1_1pointer__t.html#a666e1b16dd64813a1b455a3ea83b6b16">More...</a><br /></td></tr>
<tr class="separator:a666e1b16dd64813a1b455a3ea83b6b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df9396f5c1a41dcce4eab29947930da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1pointer__t.html#a8df9396f5c1a41dcce4eab29947930da">can_release</a> () const</td></tr>
<tr class="memdesc:a8df9396f5c1a41dcce4eab29947930da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the <a class="el" href="classwayland_1_1pointer__t.html#a666e1b16dd64813a1b455a3ea83b6b16">release</a> function is available with the currently bound version of the protocol.  <a href="classwayland_1_1pointer__t.html#a8df9396f5c1a41dcce4eab29947930da">More...</a><br /></td></tr>
<tr class="separator:a8df9396f5c1a41dcce4eab29947930da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019637a78e2d15b957bf5df4647f1170"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(uint32_t, <a class="el" href="classwayland_1_1surface__t.html">surface_t</a>, double, double)&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1pointer__t.html#a019637a78e2d15b957bf5df4647f1170">on_enter</a> ()</td></tr>
<tr class="memdesc:a019637a78e2d15b957bf5df4647f1170"><td class="mdescLeft">&#160;</td><td class="mdescRight">enter event  <a href="classwayland_1_1pointer__t.html#a019637a78e2d15b957bf5df4647f1170">More...</a><br /></td></tr>
<tr class="separator:a019637a78e2d15b957bf5df4647f1170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db737d65756420ff3bebb7f6872ffea"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(uint32_t, <a class="el" href="classwayland_1_1surface__t.html">surface_t</a>)&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1pointer__t.html#a5db737d65756420ff3bebb7f6872ffea">on_leave</a> ()</td></tr>
<tr class="memdesc:a5db737d65756420ff3bebb7f6872ffea"><td class="mdescLeft">&#160;</td><td class="mdescRight">leave event  <a href="classwayland_1_1pointer__t.html#a5db737d65756420ff3bebb7f6872ffea">More...</a><br /></td></tr>
<tr class="separator:a5db737d65756420ff3bebb7f6872ffea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeffaacb31105b899f7fc61b6f32a8a0"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(uint32_t, double, double)&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1pointer__t.html#afeffaacb31105b899f7fc61b6f32a8a0">on_motion</a> ()</td></tr>
<tr class="memdesc:afeffaacb31105b899f7fc61b6f32a8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer motion event  <a href="classwayland_1_1pointer__t.html#afeffaacb31105b899f7fc61b6f32a8a0">More...</a><br /></td></tr>
<tr class="separator:afeffaacb31105b899f7fc61b6f32a8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456627bdaad882af8cf29c88420f5f8d"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(uint32_t, uint32_t, uint32_t, pointer_button_state)&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1pointer__t.html#a456627bdaad882af8cf29c88420f5f8d">on_button</a> ()</td></tr>
<tr class="memdesc:a456627bdaad882af8cf29c88420f5f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer button event  <a href="classwayland_1_1pointer__t.html#a456627bdaad882af8cf29c88420f5f8d">More...</a><br /></td></tr>
<tr class="separator:a456627bdaad882af8cf29c88420f5f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dffc3d57ba0f519d8e01beafee9a2d"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(uint32_t, pointer_axis, double)&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1pointer__t.html#a27dffc3d57ba0f519d8e01beafee9a2d">on_axis</a> ()</td></tr>
<tr class="memdesc:a27dffc3d57ba0f519d8e01beafee9a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">axis event  <a href="classwayland_1_1pointer__t.html#a27dffc3d57ba0f519d8e01beafee9a2d">More...</a><br /></td></tr>
<tr class="separator:a27dffc3d57ba0f519d8e01beafee9a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ec548f9ca0853201863c235caeda9a"><td class="memItemLeft" align="right" valign="top">std::function&lt; void()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1pointer__t.html#a81ec548f9ca0853201863c235caeda9a">on_frame</a> ()</td></tr>
<tr class="memdesc:a81ec548f9ca0853201863c235caeda9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">end of a pointer event sequence  <a href="classwayland_1_1pointer__t.html#a81ec548f9ca0853201863c235caeda9a">More...</a><br /></td></tr>
<tr class="separator:a81ec548f9ca0853201863c235caeda9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffbc04af1fa57a107c91cb842458d07"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(pointer_axis_source)&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1pointer__t.html#acffbc04af1fa57a107c91cb842458d07">on_axis_source</a> ()</td></tr>
<tr class="memdesc:acffbc04af1fa57a107c91cb842458d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">axis source event  <a href="classwayland_1_1pointer__t.html#acffbc04af1fa57a107c91cb842458d07">More...</a><br /></td></tr>
<tr class="separator:acffbc04af1fa57a107c91cb842458d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8962336f3c5e738842dc52e7b2beb79"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(uint32_t, pointer_axis)&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1pointer__t.html#ad8962336f3c5e738842dc52e7b2beb79">on_axis_stop</a> ()</td></tr>
<tr class="memdesc:ad8962336f3c5e738842dc52e7b2beb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">axis stop event  <a href="classwayland_1_1pointer__t.html#ad8962336f3c5e738842dc52e7b2beb79">More...</a><br /></td></tr>
<tr class="separator:ad8962336f3c5e738842dc52e7b2beb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4d6c7a76b39f2c4fa842489391ece5"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(pointer_axis, int32_t)&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1pointer__t.html#a7f4d6c7a76b39f2c4fa842489391ece5">on_axis_discrete</a> ()</td></tr>
<tr class="memdesc:a7f4d6c7a76b39f2c4fa842489391ece5"><td class="mdescLeft">&#160;</td><td class="mdescRight">axis click event  <a href="classwayland_1_1pointer__t.html#a7f4d6c7a76b39f2c4fa842489391ece5">More...</a><br /></td></tr>
<tr class="separator:a7f4d6c7a76b39f2c4fa842489391ece5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273d7fd6604b65d4c4d24747b639a263"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a273d7fd6604b65d4c4d24747b639a263">get_id</a> () const</td></tr>
<tr class="memdesc:a273d7fd6604b65d4c4d24747b639a263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of a proxy object.  <a href="classwayland_1_1proxy__t.html#a273d7fd6604b65d4c4d24747b639a263">More...</a><br /></td></tr>
<tr class="separator:a273d7fd6604b65d4c4d24747b639a263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a77c6eab2f2eb4cfcca56be8a780d3e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a8a77c6eab2f2eb4cfcca56be8a780d3e">get_class</a> () const</td></tr>
<tr class="memdesc:a8a77c6eab2f2eb4cfcca56be8a780d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interface name (class) of a proxy object.  <a href="classwayland_1_1proxy__t.html#a8a77c6eab2f2eb4cfcca56be8a780d3e">More...</a><br /></td></tr>
<tr class="separator:a8a77c6eab2f2eb4cfcca56be8a780d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59444022b75257f6b27d2c464c371779"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a59444022b75257f6b27d2c464c371779">get_version</a> () const</td></tr>
<tr class="memdesc:a59444022b75257f6b27d2c464c371779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the protocol object version of a proxy object.  <a href="classwayland_1_1proxy__t.html#a59444022b75257f6b27d2c464c371779">More...</a><br /></td></tr>
<tr class="separator:a59444022b75257f6b27d2c464c371779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65253c6ac727496735c0dc42a9fd1568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9">wrapper_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a65253c6ac727496735c0dc42a9fd1568">get_wrapper_type</a> () const</td></tr>
<tr class="memdesc:a65253c6ac727496735c0dc42a9fd1568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of a proxy object.  <a href="classwayland_1_1proxy__t.html#a65253c6ac727496735c0dc42a9fd1568">More...</a><br /></td></tr>
<tr class="separator:a65253c6ac727496735c0dc42a9fd1568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2065bb6f0ba51f29fdf16b8168bb5958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a2065bb6f0ba51f29fdf16b8168bb5958">set_queue</a> (<a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a> queue)</td></tr>
<tr class="memdesc:a2065bb6f0ba51f29fdf16b8168bb5958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a proxy to an event queue.  <a href="classwayland_1_1proxy__t.html#a2065bb6f0ba51f29fdf16b8168bb5958">More...</a><br /></td></tr>
<tr class="separator:a2065bb6f0ba51f29fdf16b8168bb5958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9f256a9bfaed12ad36a357cc22df5e"><td class="memItemLeft" align="right" valign="top">wl_proxy *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a6a9f256a9bfaed12ad36a357cc22df5e">c_ptr</a> () const</td></tr>
<tr class="memdesc:a6a9f256a9bfaed12ad36a357cc22df5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the underlying C struct.  <a href="classwayland_1_1proxy__t.html#a6a9f256a9bfaed12ad36a357cc22df5e">More...</a><br /></td></tr>
<tr class="separator:a6a9f256a9bfaed12ad36a357cc22df5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c596640d7469447cb0b91dc9c8c22b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a0c596640d7469447cb0b91dc9c8c22b2">proxy_has_object</a> () const</td></tr>
<tr class="memdesc:a0c596640d7469447cb0b91dc9c8c22b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this wrapper actually wraps an object.  <a href="classwayland_1_1proxy__t.html#a0c596640d7469447cb0b91dc9c8c22b2">More...</a><br /></td></tr>
<tr class="separator:a0c596640d7469447cb0b91dc9c8c22b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa72a9121fa69ccfad6e9eff8740b5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#aafa72a9121fa69ccfad6e9eff8740b5e">operator bool</a> () const</td></tr>
<tr class="memdesc:aafa72a9121fa69ccfad6e9eff8740b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this wrapper actually wraps an object.  <a href="classwayland_1_1proxy__t.html#aafa72a9121fa69ccfad6e9eff8740b5e">More...</a><br /></td></tr>
<tr class="separator:aafa72a9121fa69ccfad6e9eff8740b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc433db4597e77caccb07f99b26a259"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a3dc433db4597e77caccb07f99b26a259">operator==</a> (const <a class="el" href="classwayland_1_1proxy__t.html">proxy_t</a> &amp;right) const</td></tr>
<tr class="memdesc:a3dc433db4597e77caccb07f99b26a259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two wrappers refer to the same object.  <a href="classwayland_1_1proxy__t.html#a3dc433db4597e77caccb07f99b26a259">More...</a><br /></td></tr>
<tr class="separator:a3dc433db4597e77caccb07f99b26a259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac460e26f384624eb96647d533314240a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#ac460e26f384624eb96647d533314240a">operator!=</a> (const <a class="el" href="classwayland_1_1proxy__t.html">proxy_t</a> &amp;right) const</td></tr>
<tr class="memdesc:ac460e26f384624eb96647d533314240a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two wrappers refer to different objects.  <a href="classwayland_1_1proxy__t.html#ac460e26f384624eb96647d533314240a">More...</a><br /></td></tr>
<tr class="separator:ac460e26f384624eb96647d533314240a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af69af8f839a5a5ea354e52705e9a43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a0af69af8f839a5a5ea354e52705e9a43">proxy_release</a> ()</td></tr>
<tr class="memdesc:a0af69af8f839a5a5ea354e52705e9a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the wrapped object (if any), making this an empty wrapper.  <a href="classwayland_1_1proxy__t.html#a0af69af8f839a5a5ea354e52705e9a43">More...</a><br /></td></tr>
<tr class="separator:a0af69af8f839a5a5ea354e52705e9a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a76e74600151aa8bcc84ecd31c11bd162"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1pointer__t.html#a76e74600151aa8bcc84ecd31c11bd162">set_cursor_since_version</a> = 1</td></tr>
<tr class="memdesc:a76e74600151aa8bcc84ecd31c11bd162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1pointer__t.html#a5303d32f8043cd58697b854b72ba93d5">set_cursor</a> function.  <a href="classwayland_1_1pointer__t.html#a76e74600151aa8bcc84ecd31c11bd162">More...</a><br /></td></tr>
<tr class="separator:a76e74600151aa8bcc84ecd31c11bd162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93022a18cbe4b2267e2b31311db27b2"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1pointer__t.html#aa93022a18cbe4b2267e2b31311db27b2">release_since_version</a> = 3</td></tr>
<tr class="memdesc:aa93022a18cbe4b2267e2b31311db27b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum protocol version required for the <a class="el" href="classwayland_1_1pointer__t.html#a666e1b16dd64813a1b455a3ea83b6b16">release</a> function.  <a href="classwayland_1_1pointer__t.html#aa93022a18cbe4b2267e2b31311db27b2">More...</a><br /></td></tr>
<tr class="separator:aa93022a18cbe4b2267e2b31311db27b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>pointer input device </p>
<p>The wl_pointer interface represents one or more input devices, such as mice, which control the pointer location and pointer_focus of a seat.</p>
<p>The wl_pointer interface generates motion, enter and leave events for the surfaces that the pointer is located over, and button and axis events for button presses, button releases and scrolling. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="egl_8cpp-example.html#_a11">egl.cpp</a>, and <a class="el" href="shm_8cpp-example.html#_a11">shm.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol_8hpp_source.html#l02505">2505</a> of file <a class="el" href="wayland-client-protocol_8hpp_source.html">wayland-client-protocol.hpp</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="afc44f0d53890db6bd32d9b2f0c6994e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc44f0d53890db6bd32d9b2f0c6994e9">&#9670;&nbsp;</a></span>wrapper_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9">wayland::proxy_t::wrapper_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Underlying wl_proxy type and properties of a <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> that affect construction, destruction, and event handling </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afc44f0d53890db6bd32d9b2f0c6994e9ac00f0c4675b91fb8b918e4079a0b1bac"></a>standard&#160;</td><td class="fielddoc"><p>C pointer is a standard type compatible with wl_proxy*. Events are dispatched and it is destructed when the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is destructed. User data is set. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc44f0d53890db6bd32d9b2f0c6994e9aebf78b512222fe4dcd14e7d5060a15b0"></a>display&#160;</td><td class="fielddoc"><p>C pointer is a wl_display*. No events are dispatched, wl_display_disconnect is called when the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is destructed. User data is set. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc44f0d53890db6bd32d9b2f0c6994e9a684a72e08f24f55b1138edd5a7c2b53e"></a>foreign&#160;</td><td class="fielddoc"><p>C pointer is a standard type compatible with wl_proxy*, but another library owns it and it should not be touched in a way that could affect the operation of the other library. No events are dispatched, wl_proxy_destroy is not called when the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is destructed, user data is not touched. Consequently, there is no reference counting for the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a>. Lifetime of such wrappers should preferably be short to minimize the chance that the owning library decides to destroy the wl_proxy. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc44f0d53890db6bd32d9b2f0c6994e9ae6cc1490287e90290ddd4e0b9efeb6d5"></a>proxy_wrapper&#160;</td><td class="fielddoc"><p>C pointer is a wl_proxy* that was constructed with wl_proxy_create_wrapper. No events are dispatched, wl_proxy_wrapper_destroy is called when the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is destroyed. Reference counting is active. A reference to the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> creating this proxy wrapper is held to extend its lifetime until after the proxy wrapper is destroyed. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="wayland-client_8hpp_source.html#l00105">105</a> of file <a class="el" href="wayland-client_8hpp_source.html">wayland-client.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6a9f256a9bfaed12ad36a357cc22df5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9f256a9bfaed12ad36a357cc22df5e">&#9670;&nbsp;</a></span>c_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wl_proxy* wayland::proxy_t::c_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the underlying C struct. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying wl_proxy wrapped by this <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> if it exists, otherwise an exception is thrown </dd></dl>

</div>
</div>
<a id="a8df9396f5c1a41dcce4eab29947930da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df9396f5c1a41dcce4eab29947930da">&#9670;&nbsp;</a></span>can_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pointer_t::can_release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the <a class="el" href="classwayland_1_1pointer__t.html#a666e1b16dd64813a1b455a3ea83b6b16">release</a> function is available with the currently bound version of the protocol. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol_8cpp_source.html#l02870">2870</a> of file <a class="el" href="wayland-client-protocol_8cpp_source.html">wayland-client-protocol.cpp</a>.</p>

</div>
</div>
<a id="a8a77c6eab2f2eb4cfcca56be8a780d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a77c6eab2f2eb4cfcca56be8a780d3e">&#9670;&nbsp;</a></span>get_class()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string wayland::proxy_t::get_class </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the interface name (class) of a proxy object. </p>
<dl class="section return"><dt>Returns</dt><dd>The interface name of the object associated with the proxy </dd></dl>

</div>
</div>
<a id="a273d7fd6604b65d4c4d24747b639a263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273d7fd6604b65d4c4d24747b639a263">&#9670;&nbsp;</a></span>get_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t wayland::proxy_t::get_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the id of a proxy object. </p>
<dl class="section return"><dt>Returns</dt><dd>The id the object associated with the proxy </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="dump_8cpp-example.html#a6">dump.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a59444022b75257f6b27d2c464c371779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59444022b75257f6b27d2c464c371779">&#9670;&nbsp;</a></span>get_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t wayland::proxy_t::get_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the protocol object version of a proxy object. </p>
<p>Gets the protocol object version of a proxy object, or 0 if the proxy was created with unversioned API.</p>
<p>A returned value of 0 means that no version information is available, so the caller must make safe assumptions about the object's real version.</p>
<p><a class="el" href="classwayland_1_1display__t.html">display_t</a> will always return version 0.</p>
<dl class="section return"><dt>Returns</dt><dd>The protocol object version of the proxy or 0 </dd></dl>

</div>
</div>
<a id="a65253c6ac727496735c0dc42a9fd1568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65253c6ac727496735c0dc42a9fd1568">&#9670;&nbsp;</a></span>get_wrapper_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9">wrapper_type</a> wayland::proxy_t::get_wrapper_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of a proxy object. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client_8hpp_source.html#l00288">288</a> of file <a class="el" href="wayland-client_8hpp_source.html">wayland-client.hpp</a>.</p>

</div>
</div>
<a id="a27dffc3d57ba0f519d8e01beafee9a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27dffc3d57ba0f519d8e01beafee9a2d">&#9670;&nbsp;</a></span>on_axis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(uint32_t, pointer_axis, double)&gt; &amp; pointer_t::on_axis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>axis event </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>timestamp with millisecond granularity </td></tr>
    <tr><td class="paramname">axis</td><td>axis type </td></tr>
    <tr><td class="paramname">value</td><td>length of vector in surface-local coordinate space</td></tr>
  </table>
  </dd>
</dl>
<p>Scroll and other axis notifications.</p>
<p>For scroll events (vertical and horizontal scroll axes), the value parameter is the length of a vector along the specified axis in a coordinate space identical to those of motion events, representing a relative movement along the specified axis.</p>
<p>For devices that support movements non-parallel to axes multiple axis events will be emitted.</p>
<p>When applicable, for example for touch pads, the server can choose to emit scroll events where the motion vector is equivalent to a motion event vector.</p>
<p>When applicable, a client can transform its content relative to the scroll distance. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol_8cpp_source.html#l02895">2895</a> of file <a class="el" href="wayland-client-protocol_8cpp_source.html">wayland-client-protocol.cpp</a>.</p>

</div>
</div>
<a id="a7f4d6c7a76b39f2c4fa842489391ece5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4d6c7a76b39f2c4fa842489391ece5">&#9670;&nbsp;</a></span>on_axis_discrete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(pointer_axis, int32_t)&gt; &amp; pointer_t::on_axis_discrete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>axis click event </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>axis type </td></tr>
    <tr><td class="paramname">discrete</td><td>number of steps</td></tr>
  </table>
  </dd>
</dl>
<p>Discrete step information for scroll and other axes.</p>
<p>This event carries the axis value of the wl_pointer.axis event in discrete steps (e.g. mouse wheel clicks).</p>
<p>This event does not occur on its own, it is coupled with a wl_pointer.axis event that represents this axis value on a continuous scale. The protocol guarantees that each axis_discrete event is always followed by exactly one axis event with the same axis number within the same wl_pointer.frame. Note that the protocol allows for other events to occur between the axis_discrete and its coupled axis event, including other axis_discrete or axis events.</p>
<p>This event is optional; continuous scrolling devices like two-finger scrolling on touchpads do not have discrete steps and do not generate this event.</p>
<p>The discrete value carries the directional information. e.g. a value of -2 is two steps towards the negative direction of this axis.</p>
<p>The axis number is identical to the axis number in the associated axis event.</p>
<p>The order of wl_pointer.axis_discrete and wl_pointer.axis_source is not guaranteed. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol_8cpp_source.html#l02915">2915</a> of file <a class="el" href="wayland-client-protocol_8cpp_source.html">wayland-client-protocol.cpp</a>.</p>

</div>
</div>
<a id="acffbc04af1fa57a107c91cb842458d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffbc04af1fa57a107c91cb842458d07">&#9670;&nbsp;</a></span>on_axis_source()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(pointer_axis_source)&gt; &amp; pointer_t::on_axis_source </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>axis source event </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis_source</td><td>source of the axis event</td></tr>
  </table>
  </dd>
</dl>
<p>Source information for scroll and other axes.</p>
<p>This event does not occur on its own. It is sent before a wl_pointer.frame event and carries the source information for all events within that frame.</p>
<p>The source specifies how this event was generated. If the source is wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be sent when the user lifts the finger off the device.</p>
<p>If the source is wl_pointer.axis_source.wheel, wl_pointer.axis_source.wheel_tilt or wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may or may not be sent. Whether a compositor sends an axis_stop event for these sources is hardware-specific and implementation-dependent; clients must not rely on receiving an axis_stop event for these scroll sources and should treat scroll sequences from these scroll sources as unterminated by default.</p>
<p>This event is optional. If the source is unknown for a particular axis event sequence, no event is sent. Only one wl_pointer.axis_source event is permitted per frame.</p>
<p>The order of wl_pointer.axis_discrete and wl_pointer.axis_source is not guaranteed. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol_8cpp_source.html#l02905">2905</a> of file <a class="el" href="wayland-client-protocol_8cpp_source.html">wayland-client-protocol.cpp</a>.</p>

</div>
</div>
<a id="ad8962336f3c5e738842dc52e7b2beb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8962336f3c5e738842dc52e7b2beb79">&#9670;&nbsp;</a></span>on_axis_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(uint32_t, pointer_axis)&gt; &amp; pointer_t::on_axis_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>axis stop event </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>timestamp with millisecond granularity </td></tr>
    <tr><td class="paramname">axis</td><td>the axis stopped with this event</td></tr>
  </table>
  </dd>
</dl>
<p>Stop notification for scroll and other axes.</p>
<p>For some wl_pointer.axis_source types, a wl_pointer.axis_stop event is sent to notify a client that the axis sequence has terminated. This enables the client to implement kinetic scrolling. See the wl_pointer.axis_source documentation for information on when this event may be generated.</p>
<p>Any wl_pointer.axis events with the same axis_source after this event should be considered as the start of a new axis motion.</p>
<p>The timestamp is to be interpreted identical to the timestamp in the wl_pointer.axis event. The timestamp value may be the same as a preceding wl_pointer.axis event. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol_8cpp_source.html#l02910">2910</a> of file <a class="el" href="wayland-client-protocol_8cpp_source.html">wayland-client-protocol.cpp</a>.</p>

</div>
</div>
<a id="a456627bdaad882af8cf29c88420f5f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456627bdaad882af8cf29c88420f5f8d">&#9670;&nbsp;</a></span>on_button()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(uint32_t, uint32_t, uint32_t, pointer_button_state)&gt; &amp; pointer_t::on_button </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pointer button event </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serial</td><td>serial number of the button event </td></tr>
    <tr><td class="paramname">time</td><td>timestamp with millisecond granularity </td></tr>
    <tr><td class="paramname">button</td><td>button that produced the event </td></tr>
    <tr><td class="paramname">state</td><td>physical state of the button</td></tr>
  </table>
  </dd>
</dl>
<p>Mouse button click and release notifications.</p>
<p>The location of the click is given by the last motion or enter event. The time argument is a timestamp with millisecond granularity, with an undefined base.</p>
<p>The button is a button code as defined in the Linux kernel's linux/input-event-codes.h header file, e.g. BTN_LEFT.</p>
<p>Any 16-bit button code value is reserved for future additions to the kernel's event code list. All other button codes above 0xFFFF are currently undefined but may be used in future versions of this protocol. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="egl_8cpp-example.html#a47">egl.cpp</a>, and <a class="el" href="shm_8cpp-example.html#a47">shm.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol_8cpp_source.html#l02890">2890</a> of file <a class="el" href="wayland-client-protocol_8cpp_source.html">wayland-client-protocol.cpp</a>.</p>

</div>
</div>
<a id="a019637a78e2d15b957bf5df4647f1170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019637a78e2d15b957bf5df4647f1170">&#9670;&nbsp;</a></span>on_enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(uint32_t, <a class="el" href="classwayland_1_1surface__t.html">surface_t</a>, double, double)&gt; &amp; pointer_t::on_enter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enter event </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serial</td><td>serial number of the enter event </td></tr>
    <tr><td class="paramname">surface</td><td>surface entered by the pointer </td></tr>
    <tr><td class="paramname">surface_x</td><td>surface-local x coordinate </td></tr>
    <tr><td class="paramname">surface_y</td><td>surface-local y coordinate</td></tr>
  </table>
  </dd>
</dl>
<p>Notification that this seat's pointer is focused on a certain surface.</p>
<p>When a seat's focus enters a surface, the pointer image is undefined and a client should respond to this event by setting an appropriate pointer image with the set_cursor request. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="egl_8cpp-example.html#a43">egl.cpp</a>, and <a class="el" href="shm_8cpp-example.html#a45">shm.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol_8cpp_source.html#l02875">2875</a> of file <a class="el" href="wayland-client-protocol_8cpp_source.html">wayland-client-protocol.cpp</a>.</p>

</div>
</div>
<a id="a81ec548f9ca0853201863c235caeda9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ec548f9ca0853201863c235caeda9a">&#9670;&nbsp;</a></span>on_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void()&gt; &amp; pointer_t::on_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>end of a pointer event sequence </p>
<p>Indicates the end of a set of events that logically belong together. A client is expected to accumulate the data in all events within the frame before proceeding.</p>
<p>All wl_pointer events before a wl_pointer.frame event belong logically together. For example, in a diagonal scroll motion the compositor will send an optional wl_pointer.axis_source event, two wl_pointer.axis events (horizontal and vertical) and finally a wl_pointer.frame event. The client may use this information to calculate a diagonal vector for scrolling.</p>
<p>When multiple wl_pointer.axis events occur within the same frame, the motion vector is the combined motion of all events. When a wl_pointer.axis and a wl_pointer.axis_stop event occur within the same frame, this indicates that axis movement in one axis has stopped but continues in the other axis. When multiple wl_pointer.axis_stop events occur within the same frame, this indicates that these axes stopped in the same instance.</p>
<p>A wl_pointer.frame event is sent for every logical event group, even if the group only contains a single wl_pointer event. Specifically, a client may get a sequence: motion, frame, button, frame, axis, frame, axis_stop, frame.</p>
<p>The wl_pointer.enter and wl_pointer.leave events are logical events generated by the compositor and not the hardware. These events are also grouped by a wl_pointer.frame. When a pointer moves from one surface to another, a compositor should group the wl_pointer.leave event within the same wl_pointer.frame. However, a client must not rely on wl_pointer.leave and wl_pointer.enter being in the same wl_pointer.frame. Compositor-specific policies may require the wl_pointer.leave and wl_pointer.enter event being split across multiple wl_pointer.frame groups. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol_8cpp_source.html#l02900">2900</a> of file <a class="el" href="wayland-client-protocol_8cpp_source.html">wayland-client-protocol.cpp</a>.</p>

</div>
</div>
<a id="a5db737d65756420ff3bebb7f6872ffea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db737d65756420ff3bebb7f6872ffea">&#9670;&nbsp;</a></span>on_leave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(uint32_t, <a class="el" href="classwayland_1_1surface__t.html">surface_t</a>)&gt; &amp; pointer_t::on_leave </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>leave event </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serial</td><td>serial number of the leave event </td></tr>
    <tr><td class="paramname">surface</td><td>surface left by the pointer</td></tr>
  </table>
  </dd>
</dl>
<p>Notification that this seat's pointer is no longer focused on a certain surface.</p>
<p>The leave notification is sent before the enter notification for the new focus. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol_8cpp_source.html#l02880">2880</a> of file <a class="el" href="wayland-client-protocol_8cpp_source.html">wayland-client-protocol.cpp</a>.</p>

</div>
</div>
<a id="afeffaacb31105b899f7fc61b6f32a8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeffaacb31105b899f7fc61b6f32a8a0">&#9670;&nbsp;</a></span>on_motion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(uint32_t, double, double)&gt; &amp; pointer_t::on_motion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pointer motion event </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>timestamp with millisecond granularity </td></tr>
    <tr><td class="paramname">surface_x</td><td>surface-local x coordinate </td></tr>
    <tr><td class="paramname">surface_y</td><td>surface-local y coordinate</td></tr>
  </table>
  </dd>
</dl>
<p>Notification of pointer location change. The arguments surface_x and surface_y are the location relative to the focused surface. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol_8cpp_source.html#l02885">2885</a> of file <a class="el" href="wayland-client-protocol_8cpp_source.html">wayland-client-protocol.cpp</a>.</p>

</div>
</div>
<a id="aafa72a9121fa69ccfad6e9eff8740b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa72a9121fa69ccfad6e9eff8740b5e">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wayland::proxy_t::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this wrapper actually wraps an object. </p>
<dl class="section return"><dt>Returns</dt><dd>true if there is an underlying object, false if this wrapper is empty </dd></dl>

</div>
</div>
<a id="ac460e26f384624eb96647d533314240a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac460e26f384624eb96647d533314240a">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wayland::proxy_t::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwayland_1_1proxy__t.html">proxy_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether two wrappers refer to different objects. </p>

</div>
</div>
<a id="a3dc433db4597e77caccb07f99b26a259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc433db4597e77caccb07f99b26a259">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wayland::proxy_t::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwayland_1_1proxy__t.html">proxy_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether two wrappers refer to the same object. </p>

</div>
</div>
<a id="a0c596640d7469447cb0b91dc9c8c22b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c596640d7469447cb0b91dc9c8c22b2">&#9670;&nbsp;</a></span>proxy_has_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wayland::proxy_t::proxy_has_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this wrapper actually wraps an object. </p>
<dl class="section return"><dt>Returns</dt><dd>true if there is an underlying object, false if this wrapper is empty </dd></dl>

</div>
</div>
<a id="a0af69af8f839a5a5ea354e52705e9a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af69af8f839a5a5ea354e52705e9a43">&#9670;&nbsp;</a></span>proxy_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wayland::proxy_t::proxy_release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the wrapped object (if any), making this an empty wrapper. </p>
<p>Note that <a class="el" href="classwayland_1_1display__t.html" title="Represents a connection to the compositor and acts as a proxy to the display singleton object.">display_t</a> instances cannot be released this way. Attempts to do so are ignored. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="foreign_display_8cpp-example.html#a1">foreign_display.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a666e1b16dd64813a1b455a3ea83b6b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666e1b16dd64813a1b455a3ea83b6b16">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pointer_t::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>release the pointer object </p>
<p>Using this request a client can tell the server that it is not going to use the pointer object anymore.</p>
<p>This request destroys the pointer proxy object, so clients must not call wl_pointer_destroy() after using this request. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol_8cpp_source.html#l02866">2866</a> of file <a class="el" href="wayland-client-protocol_8cpp_source.html">wayland-client-protocol.cpp</a>.</p>

</div>
</div>
<a id="a5303d32f8043cd58697b854b72ba93d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5303d32f8043cd58697b854b72ba93d5">&#9670;&nbsp;</a></span>set_cursor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pointer_t::set_cursor </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwayland_1_1surface__t.html">surface_t</a>&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>hotspot_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>hotspot_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the pointer surface </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serial</td><td>serial number of the enter event </td></tr>
    <tr><td class="paramname">surface</td><td>pointer surface </td></tr>
    <tr><td class="paramname">hotspot_x</td><td>surface-local x coordinate </td></tr>
    <tr><td class="paramname">hotspot_y</td><td>surface-local y coordinate</td></tr>
  </table>
  </dd>
</dl>
<p>Set the pointer surface, i.e., the surface that contains the pointer image (cursor). This request gives the surface the role of a cursor. If the surface already has another role, it raises a protocol error.</p>
<p>The cursor actually changes only if the pointer focus for this device is one of the requesting client's surfaces or the surface parameter is the current pointer surface. If there was a previous surface set with this request it is replaced. If surface is NULL, the pointer image is hidden.</p>
<p>The parameters hotspot_x and hotspot_y define the position of the pointer surface relative to the pointer location. Its top-left corner is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the coordinates of the pointer location, in surface-local coordinates.</p>
<p>On surface.attach requests to the pointer surface, hotspot_x and hotspot_y are decremented by the x and y parameters passed to the request. Attach must be confirmed by wl_surface.commit as usual.</p>
<p>The hotspot can also be updated by passing the currently set pointer surface to this request with new values for hotspot_x and hotspot_y.</p>
<p>The current and pending input regions of the wl_surface are cleared, and wl_surface.set_input_region is ignored until the wl_surface is no longer used as the cursor. When the use as a cursor ends, the current and pending input regions become undefined, and the wl_surface is unmapped. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="egl_8cpp-example.html#a46">egl.cpp</a>, and <a class="el" href="shm_8cpp-example.html#a46">shm.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol_8cpp_source.html#l02861">2861</a> of file <a class="el" href="wayland-client-protocol_8cpp_source.html">wayland-client-protocol.cpp</a>.</p>

</div>
</div>
<a id="a2065bb6f0ba51f29fdf16b8168bb5958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2065bb6f0ba51f29fdf16b8168bb5958">&#9670;&nbsp;</a></span>set_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wayland::proxy_t::set_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a proxy to an event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The event queue that will handle this proxy</td></tr>
  </table>
  </dd>
</dl>
<p>Assign proxy to event queue. Events coming from proxy will be queued in queue instead of the display's main queue.</p>
<p>See also: <a class="el" href="classwayland_1_1display__t.html#a967a3e54ca3bffb6ba05abf44aef1840" title="Dispatch events in an event queue.">display_t::dispatch_queue()</a>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="proxy_wrapper_8cpp-example.html#a5">proxy_wrapper.cpp</a>.</dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa93022a18cbe4b2267e2b31311db27b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93022a18cbe4b2267e2b31311db27b2">&#9670;&nbsp;</a></span>release_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::pointer_t::release_since_version = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1pointer__t.html#a666e1b16dd64813a1b455a3ea83b6b16">release</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol_8hpp_source.html#l02594">2594</a> of file <a class="el" href="wayland-client-protocol_8hpp_source.html">wayland-client-protocol.hpp</a>.</p>

</div>
</div>
<a id="a76e74600151aa8bcc84ecd31c11bd162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e74600151aa8bcc84ecd31c11bd162">&#9670;&nbsp;</a></span>set_cursor_since_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t wayland::pointer_t::set_cursor_since_version = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum protocol version required for the <a class="el" href="classwayland_1_1pointer__t.html#a5303d32f8043cd58697b854b72ba93d5">set_cursor</a> function. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client-protocol_8hpp_source.html#l02579">2579</a> of file <a class="el" href="wayland-client-protocol_8hpp_source.html">wayland-client-protocol.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>build/<a class="el" href="wayland-client-protocol_8hpp_source.html">wayland-client-protocol.hpp</a></li>
<li>build/<a class="el" href="wayland-client-protocol_8cpp_source.html">wayland-client-protocol.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>wayland</b></li><li class="navelem"><a class="el" href="classwayland_1_1pointer__t.html">pointer_t</a></li>
    <li class="footer">Generated on Tue Oct 8 2019 20:07:40 for Wayland++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
