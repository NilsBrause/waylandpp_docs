<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wayland++: wayland::display_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wayland++
   &#160;<span id="projectnumber">0.2.6</span>
   </div>
   <div id="projectbrief">C++ Bindings for Wayland</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classwayland_1_1display__t.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classwayland_1_1display__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">wayland::display_t Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a connection to the compositor and acts as a proxy to the display singleton object.  
 <a href="classwayland_1_1display__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="wayland-client_8hpp_source.html">wayland-client.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for wayland::display_t:</div>
<div class="dyncontent">
<div class="center"><img src="classwayland_1_1display__t__inherit__graph.png" border="0" usemap="#wayland_1_1display__t_inherit__map" alt="Inheritance graph"/></div>
<map name="wayland_1_1display__t_inherit__map" id="wayland_1_1display__t_inherit__map">
<area shape="rect" title="Represents a connection to the compositor and acts as a proxy to the display singleton object." alt="" coords="5,80,149,107"/>
<area shape="rect" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side." alt="" coords="10,5,145,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for wayland::display_t:</div>
<div class="dyncontent">
<div class="center"><img src="classwayland_1_1display__t__coll__graph.png" border="0" usemap="#wayland_1_1display__t_coll__map" alt="Collaboration graph"/></div>
<map name="wayland_1_1display__t_coll__map" id="wayland_1_1display__t_coll__map">
<area shape="rect" title="Represents a connection to the compositor and acts as a proxy to the display singleton object." alt="" coords="5,80,149,107"/>
<area shape="rect" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side." alt="" coords="10,5,145,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afc44f0d53890db6bd32d9b2f0c6994e9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9">wrapper_type</a> { <a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9ac00f0c4675b91fb8b918e4079a0b1bac">wrapper_type::standard</a>, 
<a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9aebf78b512222fe4dcd14e7d5060a15b0">wrapper_type::display</a>, 
<a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9a684a72e08f24f55b1138edd5a7c2b53e">wrapper_type::foreign</a>, 
<a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9ae6cc1490287e90290ddd4e0b9efeb6d5">wrapper_type::proxy_wrapper</a>
 }</td></tr>
<tr class="separator:afc44f0d53890db6bd32d9b2f0c6994e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abd755adf979940de20d6f49a629150f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#abd755adf979940de20d6f49a629150f4">display_t</a> (int fd)</td></tr>
<tr class="memdesc:abd755adf979940de20d6f49a629150f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to Wayland display on an already open fd.  <a href="classwayland_1_1display__t.html#abd755adf979940de20d6f49a629150f4">More...</a><br /></td></tr>
<tr class="separator:abd755adf979940de20d6f49a629150f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b38247b736f6f75443b1b3a020b8ac6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#a5b38247b736f6f75443b1b3a020b8ac6">display_t</a> (std::string name=&quot;&quot;)</td></tr>
<tr class="memdesc:a5b38247b736f6f75443b1b3a020b8ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to a Wayland display.  <a href="classwayland_1_1display__t.html#a5b38247b736f6f75443b1b3a020b8ac6">More...</a><br /></td></tr>
<tr class="separator:a5b38247b736f6f75443b1b3a020b8ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb23062177d74c46993ab76441e55752"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#aeb23062177d74c46993ab76441e55752">display_t</a> (wl_display *display)</td></tr>
<tr class="memdesc:aeb23062177d74c46993ab76441e55752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use an existing connection to a Wayland display to construct a waylandpp <a class="el" href="classwayland_1_1display__t.html" title="Represents a connection to the compositor and acts as a proxy to the display singleton object.">display_t</a>.  <a href="classwayland_1_1display__t.html#aeb23062177d74c46993ab76441e55752">More...</a><br /></td></tr>
<tr class="separator:aeb23062177d74c46993ab76441e55752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa446e9c0a6ac070b5398b31914ed4323"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#aa446e9c0a6ac070b5398b31914ed4323">~display_t</a> ()</td></tr>
<tr class="memdesc:aa446e9c0a6ac070b5398b31914ed4323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a connection to a Wayland display.  <a href="classwayland_1_1display__t.html#aa446e9c0a6ac070b5398b31914ed4323">More...</a><br /></td></tr>
<tr class="separator:aa446e9c0a6ac070b5398b31914ed4323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea381b20a7ea4f6cb58008ce2f37814a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#aea381b20a7ea4f6cb58008ce2f37814a">create_queue</a> ()</td></tr>
<tr class="memdesc:aea381b20a7ea4f6cb58008ce2f37814a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new event queue for this display.  <a href="classwayland_1_1display__t.html#aea381b20a7ea4f6cb58008ce2f37814a">More...</a><br /></td></tr>
<tr class="separator:aea381b20a7ea4f6cb58008ce2f37814a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6b8855f9982c99ace3c5964df8d8af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#a3f6b8855f9982c99ace3c5964df8d8af">get_fd</a> ()</td></tr>
<tr class="memdesc:a3f6b8855f9982c99ace3c5964df8d8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a display context's file descriptor.  <a href="classwayland_1_1display__t.html#a3f6b8855f9982c99ace3c5964df8d8af">More...</a><br /></td></tr>
<tr class="separator:a3f6b8855f9982c99ace3c5964df8d8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61af681e532c101f2511781e2af59bb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#a61af681e532c101f2511781e2af59bb8">roundtrip</a> ()</td></tr>
<tr class="memdesc:a61af681e532c101f2511781e2af59bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until all pending request are processed by the server.  <a href="classwayland_1_1display__t.html#a61af681e532c101f2511781e2af59bb8">More...</a><br /></td></tr>
<tr class="separator:a61af681e532c101f2511781e2af59bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ebb1e2ccf3fed3c4c6f15d95700e20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#a49ebb1e2ccf3fed3c4c6f15d95700e20">roundtrip_queue</a> (<a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a> queue)</td></tr>
<tr class="memdesc:a49ebb1e2ccf3fed3c4c6f15d95700e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until all pending request are processed by the server.  <a href="classwayland_1_1display__t.html#a49ebb1e2ccf3fed3c4c6f15d95700e20">More...</a><br /></td></tr>
<tr class="separator:a49ebb1e2ccf3fed3c4c6f15d95700e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc3da19815c40564dcd923ce7d83961"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwayland_1_1read__intent.html">read_intent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#afbc3da19815c40564dcd923ce7d83961">obtain_read_intent</a> ()</td></tr>
<tr class="memdesc:afbc3da19815c40564dcd923ce7d83961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Announce calling thread's intention to read events from the Wayland display file descriptor.  <a href="classwayland_1_1display__t.html#afbc3da19815c40564dcd923ce7d83961">More...</a><br /></td></tr>
<tr class="separator:afbc3da19815c40564dcd923ce7d83961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00648a8a69ff81ca0291e662b82bc08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwayland_1_1read__intent.html">read_intent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#ad00648a8a69ff81ca0291e662b82bc08">obtain_queue_read_intent</a> (<a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a> queue)</td></tr>
<tr class="memdesc:ad00648a8a69ff81ca0291e662b82bc08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Announce calling thread's intention to read events from the Wayland display file descriptor.  <a href="classwayland_1_1display__t.html#ad00648a8a69ff81ca0291e662b82bc08">More...</a><br /></td></tr>
<tr class="separator:ad00648a8a69ff81ca0291e662b82bc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967a3e54ca3bffb6ba05abf44aef1840"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#a967a3e54ca3bffb6ba05abf44aef1840">dispatch_queue</a> (<a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a> queue)</td></tr>
<tr class="memdesc:a967a3e54ca3bffb6ba05abf44aef1840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch events in an event queue.  <a href="classwayland_1_1display__t.html#a967a3e54ca3bffb6ba05abf44aef1840">More...</a><br /></td></tr>
<tr class="separator:a967a3e54ca3bffb6ba05abf44aef1840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105fe6b23e309586523747f7912bb0ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#a105fe6b23e309586523747f7912bb0ce">dispatch_queue_pending</a> (<a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a> queue)</td></tr>
<tr class="memdesc:a105fe6b23e309586523747f7912bb0ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch pending events in an event queue.  <a href="classwayland_1_1display__t.html#a105fe6b23e309586523747f7912bb0ce">More...</a><br /></td></tr>
<tr class="separator:a105fe6b23e309586523747f7912bb0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5e46126e5ad4a35158e670c0644b38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#a2d5e46126e5ad4a35158e670c0644b38">dispatch</a> ()</td></tr>
<tr class="memdesc:a2d5e46126e5ad4a35158e670c0644b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process incoming events.  <a href="classwayland_1_1display__t.html#a2d5e46126e5ad4a35158e670c0644b38">More...</a><br /></td></tr>
<tr class="separator:a2d5e46126e5ad4a35158e670c0644b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02379cb5da8a28e29f02f910baf96495"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#a02379cb5da8a28e29f02f910baf96495">dispatch_pending</a> ()</td></tr>
<tr class="memdesc:a02379cb5da8a28e29f02f910baf96495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch main queue events without reading from the display fd.  <a href="classwayland_1_1display__t.html#a02379cb5da8a28e29f02f910baf96495">More...</a><br /></td></tr>
<tr class="separator:a02379cb5da8a28e29f02f910baf96495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3333b70e8edb633874c70a068ea6f794"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#a3333b70e8edb633874c70a068ea6f794">get_error</a> () const</td></tr>
<tr class="memdesc:a3333b70e8edb633874c70a068ea6f794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the last error that occurred on a display.  <a href="classwayland_1_1display__t.html#a3333b70e8edb633874c70a068ea6f794">More...</a><br /></td></tr>
<tr class="separator:a3333b70e8edb633874c70a068ea6f794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c76ff1bc339afa823d1eab3ad00042"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; int, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#ad8c76ff1bc339afa823d1eab3ad00042">flush</a> ()</td></tr>
<tr class="memdesc:ad8c76ff1bc339afa823d1eab3ad00042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send all buffered requests on the display to the server.  <a href="classwayland_1_1display__t.html#ad8c76ff1bc339afa823d1eab3ad00042">More...</a><br /></td></tr>
<tr class="separator:ad8c76ff1bc339afa823d1eab3ad00042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957166bc2dd6b48cce65b290d446d3ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwayland_1_1callback__t.html">callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#a957166bc2dd6b48cce65b290d446d3ba">sync</a> ()</td></tr>
<tr class="memdesc:a957166bc2dd6b48cce65b290d446d3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchronous roundtrip  <a href="classwayland_1_1display__t.html#a957166bc2dd6b48cce65b290d446d3ba">More...</a><br /></td></tr>
<tr class="separator:a957166bc2dd6b48cce65b290d446d3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78598b90a108f72d6835917d8b2cc1c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwayland_1_1registry__t.html">registry_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#a78598b90a108f72d6835917d8b2cc1c5">get_registry</a> ()</td></tr>
<tr class="memdesc:a78598b90a108f72d6835917d8b2cc1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">get global registry object  <a href="classwayland_1_1display__t.html#a78598b90a108f72d6835917d8b2cc1c5">More...</a><br /></td></tr>
<tr class="separator:a78598b90a108f72d6835917d8b2cc1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11eb8b5d61dfdf782fdec43b40fade00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwayland_1_1display__t.html">display_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1display__t.html#a11eb8b5d61dfdf782fdec43b40fade00">proxy_create_wrapper</a> ()</td></tr>
<tr class="memdesc:a11eb8b5d61dfdf782fdec43b40fade00"><td class="mdescLeft">&#160;</td><td class="mdescRight">create proxy wrapper for this display  <a href="classwayland_1_1display__t.html#a11eb8b5d61dfdf782fdec43b40fade00">More...</a><br /></td></tr>
<tr class="separator:a11eb8b5d61dfdf782fdec43b40fade00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273d7fd6604b65d4c4d24747b639a263"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a273d7fd6604b65d4c4d24747b639a263">get_id</a> () const</td></tr>
<tr class="memdesc:a273d7fd6604b65d4c4d24747b639a263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of a proxy object.  <a href="classwayland_1_1proxy__t.html#a273d7fd6604b65d4c4d24747b639a263">More...</a><br /></td></tr>
<tr class="separator:a273d7fd6604b65d4c4d24747b639a263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a77c6eab2f2eb4cfcca56be8a780d3e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a8a77c6eab2f2eb4cfcca56be8a780d3e">get_class</a> () const</td></tr>
<tr class="memdesc:a8a77c6eab2f2eb4cfcca56be8a780d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interface name (class) of a proxy object.  <a href="classwayland_1_1proxy__t.html#a8a77c6eab2f2eb4cfcca56be8a780d3e">More...</a><br /></td></tr>
<tr class="separator:a8a77c6eab2f2eb4cfcca56be8a780d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59444022b75257f6b27d2c464c371779"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a59444022b75257f6b27d2c464c371779">get_version</a> () const</td></tr>
<tr class="memdesc:a59444022b75257f6b27d2c464c371779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the protocol object version of a proxy object.  <a href="classwayland_1_1proxy__t.html#a59444022b75257f6b27d2c464c371779">More...</a><br /></td></tr>
<tr class="separator:a59444022b75257f6b27d2c464c371779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65253c6ac727496735c0dc42a9fd1568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9">wrapper_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a65253c6ac727496735c0dc42a9fd1568">get_wrapper_type</a> () const</td></tr>
<tr class="memdesc:a65253c6ac727496735c0dc42a9fd1568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of a proxy object.  <a href="classwayland_1_1proxy__t.html#a65253c6ac727496735c0dc42a9fd1568">More...</a><br /></td></tr>
<tr class="separator:a65253c6ac727496735c0dc42a9fd1568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2065bb6f0ba51f29fdf16b8168bb5958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a2065bb6f0ba51f29fdf16b8168bb5958">set_queue</a> (<a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a> queue)</td></tr>
<tr class="memdesc:a2065bb6f0ba51f29fdf16b8168bb5958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a proxy to an event queue.  <a href="classwayland_1_1proxy__t.html#a2065bb6f0ba51f29fdf16b8168bb5958">More...</a><br /></td></tr>
<tr class="separator:a2065bb6f0ba51f29fdf16b8168bb5958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9f256a9bfaed12ad36a357cc22df5e"><td class="memItemLeft" align="right" valign="top">wl_proxy *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a6a9f256a9bfaed12ad36a357cc22df5e">c_ptr</a> () const</td></tr>
<tr class="memdesc:a6a9f256a9bfaed12ad36a357cc22df5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the underlying C struct.  <a href="classwayland_1_1proxy__t.html#a6a9f256a9bfaed12ad36a357cc22df5e">More...</a><br /></td></tr>
<tr class="separator:a6a9f256a9bfaed12ad36a357cc22df5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c596640d7469447cb0b91dc9c8c22b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a0c596640d7469447cb0b91dc9c8c22b2">proxy_has_object</a> () const</td></tr>
<tr class="memdesc:a0c596640d7469447cb0b91dc9c8c22b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this wrapper actually wraps an object.  <a href="classwayland_1_1proxy__t.html#a0c596640d7469447cb0b91dc9c8c22b2">More...</a><br /></td></tr>
<tr class="separator:a0c596640d7469447cb0b91dc9c8c22b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa72a9121fa69ccfad6e9eff8740b5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#aafa72a9121fa69ccfad6e9eff8740b5e">operator bool</a> () const</td></tr>
<tr class="memdesc:aafa72a9121fa69ccfad6e9eff8740b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this wrapper actually wraps an object.  <a href="classwayland_1_1proxy__t.html#aafa72a9121fa69ccfad6e9eff8740b5e">More...</a><br /></td></tr>
<tr class="separator:aafa72a9121fa69ccfad6e9eff8740b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc433db4597e77caccb07f99b26a259"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a3dc433db4597e77caccb07f99b26a259">operator==</a> (const <a class="el" href="classwayland_1_1proxy__t.html">proxy_t</a> &amp;right) const</td></tr>
<tr class="memdesc:a3dc433db4597e77caccb07f99b26a259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two wrappers refer to the same object.  <a href="classwayland_1_1proxy__t.html#a3dc433db4597e77caccb07f99b26a259">More...</a><br /></td></tr>
<tr class="separator:a3dc433db4597e77caccb07f99b26a259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac460e26f384624eb96647d533314240a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#ac460e26f384624eb96647d533314240a">operator!=</a> (const <a class="el" href="classwayland_1_1proxy__t.html">proxy_t</a> &amp;right) const</td></tr>
<tr class="memdesc:ac460e26f384624eb96647d533314240a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two wrappers refer to different objects.  <a href="classwayland_1_1proxy__t.html#ac460e26f384624eb96647d533314240a">More...</a><br /></td></tr>
<tr class="separator:ac460e26f384624eb96647d533314240a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af69af8f839a5a5ea354e52705e9a43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwayland_1_1proxy__t.html#a0af69af8f839a5a5ea354e52705e9a43">proxy_release</a> ()</td></tr>
<tr class="memdesc:a0af69af8f839a5a5ea354e52705e9a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the wrapped object (if any), making this an empty wrapper.  <a href="classwayland_1_1proxy__t.html#a0af69af8f839a5a5ea354e52705e9a43">More...</a><br /></td></tr>
<tr class="separator:a0af69af8f839a5a5ea354e52705e9a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a connection to the compositor and acts as a proxy to the display singleton object. </p>
<p>A <a class="el" href="classwayland_1_1display__t.html" title="Represents a connection to the compositor and acts as a proxy to the display singleton object.">display_t</a> object represents a client connection to a Wayland compositor. It is created with display_t::display_t(). A connection is terminated using <a class="el" href="classwayland_1_1display__t.html#aa446e9c0a6ac070b5398b31914ed4323" title="Close a connection to a Wayland display.">display_t::~display_t()</a>.</p>
<p>A <a class="el" href="classwayland_1_1display__t.html" title="Represents a connection to the compositor and acts as a proxy to the display singleton object.">display_t</a> is also used as the proxy for the display singleton object on the compositor side. A <a class="el" href="classwayland_1_1display__t.html" title="Represents a connection to the compositor and acts as a proxy to the display singleton object.">display_t</a> object handles all the data sent from and to the compositor. When a <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> marshals a request, it will write its wire representation to the display's write buffer. The data is sent to the compositor when the client calls <a class="el" href="classwayland_1_1display__t.html#ad8c76ff1bc339afa823d1eab3ad00042" title="Send all buffered requests on the display to the server.">display_t::flush()</a>.</p>
<p>Incoming data is handled in two steps: queueing and dispatching. In the queue step, the data coming from the display fd is interpreted and added to a queue. On the dispatch step, the handler for the incoming event set by the client on the corresponding <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is called.</p>
<p>A display has at least one event queue, called the main queue. Clients can create additional event queues with <a class="el" href="classwayland_1_1display__t.html#aea381b20a7ea4f6cb58008ce2f37814a" title="Create a new event queue for this display.">display_t::create_queue()</a> and assign <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a>'s to it. Events occurring in a particular proxy are always queued in its assigned queue. A client can ensure that a certain assumption, such as holding a lock or running from a given thread, is true when a proxy event handler is called by assigning that proxy to an event queue and making sure that this queue is only dispatched when the assumption holds.</p>
<p>The main queue is dispatched by calling <a class="el" href="classwayland_1_1display__t.html#a2d5e46126e5ad4a35158e670c0644b38" title="Process incoming events.">display_t::dispatch()</a>. This will dispatch any events queued on the main queue and attempt to read from the display fd if its empty. Events read are then queued on the appropriate queues according to the proxy assignment. Calling that function makes the calling thread the main thread.</p>
<p>A user created queue is dispatched with <a class="el" href="classwayland_1_1display__t.html#a967a3e54ca3bffb6ba05abf44aef1840" title="Dispatch events in an event queue.">display_t::dispatch_queue()</a>. If there are no events to dispatch this function will block. If this is called by the main thread, this will attempt to read data from the display fd and queue any events on the appropriate queues. If calling from any other thread, the function will block until the main thread queues an event on the queue being dispatched.</p>
<p>A real world example of event queue usage is Mesa's implementation of eglSwapBuffers() for the Wayland platform. This function might need to block until a frame callback is received, but dispatching the main queue could cause an event handler on the client to start drawing again. This problem is solved using another event queue, so that only the events handled by the EGL code are dispatched during the block.</p>
<p>This creates a problem where the main thread dispatches a non-main queue, reading all the data from the display fd. If the application would call poll(2) after that it would block, even though there might be events queued on the main queue. Those events should be dispatched with <a class="el" href="classwayland_1_1display__t.html#a02379cb5da8a28e29f02f910baf96495" title="Dispatch main queue events without reading from the display fd.">display_t::dispatch_pending()</a> before flushing and blocking. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="dump_8cpp-example.html#_a0">dump.cpp</a>, <a class="el" href="egl_8cpp-example.html#_a0">egl.cpp</a>, <a class="el" href="foreign_display_8cpp-example.html#_a2">foreign_display.cpp</a>, <a class="el" href="proxy_wrapper_8cpp-example.html#_a0">proxy_wrapper.cpp</a>, and <a class="el" href="shm_8cpp-example.html#_a0">shm.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wayland-client_8hpp_source.html#l00463">463</a> of file <a class="el" href="wayland-client_8hpp_source.html">wayland-client.hpp</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="afc44f0d53890db6bd32d9b2f0c6994e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc44f0d53890db6bd32d9b2f0c6994e9">&#9670;&nbsp;</a></span>wrapper_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9">wayland::proxy_t::wrapper_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Underlying wl_proxy type and properties of a <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> that affect construction, destruction, and event handling </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afc44f0d53890db6bd32d9b2f0c6994e9ac00f0c4675b91fb8b918e4079a0b1bac"></a>standard&#160;</td><td class="fielddoc"><p>C pointer is a standard type compatible with wl_proxy*. Events are dispatched and it is destructed when the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is destructed. User data is set. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc44f0d53890db6bd32d9b2f0c6994e9aebf78b512222fe4dcd14e7d5060a15b0"></a>display&#160;</td><td class="fielddoc"><p>C pointer is a wl_display*. No events are dispatched, wl_display_disconnect is called when the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is destructed. User data is set. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc44f0d53890db6bd32d9b2f0c6994e9a684a72e08f24f55b1138edd5a7c2b53e"></a>foreign&#160;</td><td class="fielddoc"><p>C pointer is a standard type compatible with wl_proxy*, but another library owns it and it should not be touched in a way that could affect the operation of the other library. No events are dispatched, wl_proxy_destroy is not called when the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is destructed, user data is not touched. Consequently, there is no reference counting for the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a>. Lifetime of such wrappers should preferably be short to minimize the chance that the owning library decides to destroy the wl_proxy. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc44f0d53890db6bd32d9b2f0c6994e9ae6cc1490287e90290ddd4e0b9efeb6d5"></a>proxy_wrapper&#160;</td><td class="fielddoc"><p>C pointer is a wl_proxy* that was constructed with wl_proxy_create_wrapper. No events are dispatched, wl_proxy_wrapper_destroy is called when the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> is destroyed. Reference counting is active. A reference to the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> creating this proxy wrapper is held to extend its lifetime until after the proxy wrapper is destroyed. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="wayland-client_8hpp_source.html#l00105">105</a> of file <a class="el" href="wayland-client_8hpp_source.html">wayland-client.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abd755adf979940de20d6f49a629150f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd755adf979940de20d6f49a629150f4">&#9670;&nbsp;</a></span>display_t() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wayland::display_t::display_t </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to Wayland display on an already open fd. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The fd to use for the connection</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="classwayland_1_1display__t.html" title="Represents a connection to the compositor and acts as a proxy to the display singleton object.">display_t</a> takes ownership of the fd and will close it when the display is destroyed. The fd will also be closed in case of failure. </p>

</div>
</div>
<a id="a5b38247b736f6f75443b1b3a020b8ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b38247b736f6f75443b1b3a020b8ac6">&#9670;&nbsp;</a></span>display_t() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wayland::display_t::display_t </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to a Wayland display. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Optional name of the Wayland display to connect to</td></tr>
  </table>
  </dd>
</dl>
<p>Connect to the Wayland display named name. If name is empty, its value will be replaced with the WAYLAND_DISPLAY environment variable if it is set, otherwise display "wayland-0" will be used. </p>

</div>
</div>
<a id="aeb23062177d74c46993ab76441e55752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb23062177d74c46993ab76441e55752">&#9670;&nbsp;</a></span>display_t() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wayland::display_t::display_t </td>
          <td>(</td>
          <td class="paramtype">wl_display *&#160;</td>
          <td class="paramname"><em>display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use an existing connection to a Wayland display to construct a waylandpp <a class="el" href="classwayland_1_1display__t.html" title="Represents a connection to the compositor and acts as a proxy to the display singleton object.">display_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>C wl_display pointer to use; must not be nullptr</td></tr>
  </table>
  </dd>
</dl>
<p>A wl_display* that was already established using the C wayland-client API is wrapped in an waylandpp <a class="el" href="classwayland_1_1display__t.html" title="Represents a connection to the compositor and acts as a proxy to the display singleton object.">display_t</a> instance so it can be used easily from C++. Ownership of the display is not taken, so this may be used for wrapping a wl_display connection established by another library.</p>
<p>On destruction of the <a class="el" href="classwayland_1_1display__t.html" title="Represents a connection to the compositor and acts as a proxy to the display singleton object.">display_t</a>, wl_display_disconnect is not called and no resources are freed. It is the responsibility of the caller to make sure that the wl_display and the <a class="el" href="classwayland_1_1display__t.html" title="Represents a connection to the compositor and acts as a proxy to the display singleton object.">display_t</a> are not used simultaneously in incompatible ways. It is especially problematic if the wl_display is destroyed while the <a class="el" href="classwayland_1_1display__t.html" title="Represents a connection to the compositor and acts as a proxy to the display singleton object.">display_t</a> wrapper is still being used.</p>
<p>Whether the wl_display or the <a class="el" href="classwayland_1_1display__t.html" title="Represents a connection to the compositor and acts as a proxy to the display singleton object.">display_t</a> is destructed first ultimately does not matter, but any waylandpp <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> instances must be destructed or have their owned objects released before the wl_display is destroyed. Otherwise, the <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> destructor will try to free the underlying wl_proxy that was already destroyed together with the wl_display. </p>

</div>
</div>
<a id="aa446e9c0a6ac070b5398b31914ed4323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa446e9c0a6ac070b5398b31914ed4323">&#9670;&nbsp;</a></span>~display_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wayland::display_t::~display_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a connection to a Wayland display. </p>
<p>Close the connection to display and free all resources associated with it. This does not apply to <a class="el" href="classwayland_1_1display__t.html" title="Represents a connection to the compositor and acts as a proxy to the display singleton object.">display_t</a> instances that are wrappers for a pre-established C wl_display. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6a9f256a9bfaed12ad36a357cc22df5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9f256a9bfaed12ad36a357cc22df5e">&#9670;&nbsp;</a></span>c_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wl_proxy* wayland::proxy_t::c_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the underlying C struct. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying wl_proxy wrapped by this <a class="el" href="classwayland_1_1proxy__t.html" title="Represents a protocol object on the client side.">proxy_t</a> if it exists, otherwise an exception is thrown </dd></dl>

</div>
</div>
<a id="aea381b20a7ea4f6cb58008ce2f37814a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea381b20a7ea4f6cb58008ce2f37814a">&#9670;&nbsp;</a></span>create_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a> wayland::display_t::create_queue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new event queue for this display. </p>
<dl class="section return"><dt>Returns</dt><dd>A new event queue associated with this display or NULL on failure. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="proxy_wrapper_8cpp-example.html#a3">proxy_wrapper.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2d5e46126e5ad4a35158e670c0644b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5e46126e5ad4a35158e670c0644b38">&#9670;&nbsp;</a></span>dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wayland::display_t::dispatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process incoming events. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of dispatched events </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>on failure</td></tr>
  </table>
  </dd>
</dl>
<p>Dispatch the display's main event queue.</p>
<p>If the main event queue is empty, this function blocks until there are events to be read from the display fd. Events are read and queued on the appropriate event queues. Finally, events on the main event queue are dispatched.</p>
<p>Note: It is not possible to check if there are events on the main queue or not. For dispatching main queue events without blocking, see <a class="el" href="classwayland_1_1display__t.html#a02379cb5da8a28e29f02f910baf96495" title="Dispatch main queue events without reading from the display fd.">display_t::dispatch_pending()</a>. Calling this will release the display file descriptor if this thread acquired it using display_t::acquire_fd().</p>
<p>See also: <a class="el" href="classwayland_1_1display__t.html#a02379cb5da8a28e29f02f910baf96495" title="Dispatch main queue events without reading from the display fd.">display_t::dispatch_pending()</a>, <a class="el" href="classwayland_1_1display__t.html#a967a3e54ca3bffb6ba05abf44aef1840" title="Dispatch events in an event queue.">display_t::dispatch_queue()</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="egl_8cpp-example.html#a51">egl.cpp</a>, and <a class="el" href="shm_8cpp-example.html#a51">shm.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a02379cb5da8a28e29f02f910baf96495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02379cb5da8a28e29f02f910baf96495">&#9670;&nbsp;</a></span>dispatch_pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wayland::display_t::dispatch_pending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch main queue events without reading from the display fd. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of dispatched events </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>on failure</td></tr>
  </table>
  </dd>
</dl>
<p>This function dispatches events on the main event queue. It does not attempt to read the display fd and simply returns zero if the main queue is empty, i.e., it doesn't block.</p>
<p>This is necessary when a client's main loop wakes up on some fd other than the display fd (network socket, timer fd, etc) and calls wl_display_dispatch_queue() from that callback. This may queue up events in the main queue while reading all data from the display fd. When the main thread returns to the main loop to block, the display fd no longer has data, causing a call to poll(2) (or similar functions) to block indefinitely, even though there are events ready to dispatch.</p>
<p>To proper integrate the wayland display fd into a main loop, the client should always call <a class="el" href="classwayland_1_1display__t.html#a02379cb5da8a28e29f02f910baf96495" title="Dispatch main queue events without reading from the display fd.">display_t::dispatch_pending()</a> and then <a class="el" href="classwayland_1_1display__t.html#ad8c76ff1bc339afa823d1eab3ad00042" title="Send all buffered requests on the display to the server.">display_t::flush()</a> prior to going back to sleep. At that point, the fd typically doesn't have data so attempting I/O could block, but events queued up on the main queue should be dispatched.</p>
<p>A real-world example is a main loop that wakes up on a timerfd (or a sound card fd becoming writable, for example in a video player), which then triggers GL rendering and eventually eglSwapBuffers(). eglSwapBuffers() may call <a class="el" href="classwayland_1_1display__t.html#a967a3e54ca3bffb6ba05abf44aef1840" title="Dispatch events in an event queue.">display_t::dispatch_queue()</a> if it didn't receive the frame event for the previous frame, and as such queue events in the main queue. Note: Calling this makes the current thread the main one.</p>
<p>See also: <a class="el" href="classwayland_1_1display__t.html#a2d5e46126e5ad4a35158e670c0644b38" title="Process incoming events.">display_t::dispatch()</a>, <a class="el" href="classwayland_1_1display__t.html#a967a3e54ca3bffb6ba05abf44aef1840" title="Dispatch events in an event queue.">display_t::dispatch_queue()</a>, <a class="el" href="classwayland_1_1display__t.html#ad8c76ff1bc339afa823d1eab3ad00042" title="Send all buffered requests on the display to the server.">display_t::flush()</a> </p>

</div>
</div>
<a id="a967a3e54ca3bffb6ba05abf44aef1840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967a3e54ca3bffb6ba05abf44aef1840">&#9670;&nbsp;</a></span>dispatch_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wayland::display_t::dispatch_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch events in an event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The event queue to dispatch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of dispatched events </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>on failure</td></tr>
  </table>
  </dd>
</dl>
<p>Dispatch all incoming events for objects assigned to the given event queue. On failure -1 is returned and errno set appropriately.</p>
<p>This function blocks if there are no events to dispatch. If calling from the main thread, it will block reading data from the display fd. For other threads this will block until the main thread queues events on the queue passed as argument. </p>

</div>
</div>
<a id="a105fe6b23e309586523747f7912bb0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105fe6b23e309586523747f7912bb0ce">&#9670;&nbsp;</a></span>dispatch_queue_pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wayland::display_t::dispatch_queue_pending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch pending events in an event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The event queue to dispatch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of dispatched events </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>on failure</td></tr>
  </table>
  </dd>
</dl>
<p>Dispatch all incoming events for objects assigned to the given event queue. On failure -1 is returned and errno set appropriately. If there are no events queued, this function returns immediately. </p>

</div>
</div>
<a id="ad8c76ff1bc339afa823d1eab3ad00042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c76ff1bc339afa823d1eab3ad00042">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;int, bool&gt; wayland::display_t::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send all buffered requests on the display to the server. </p>
<dl class="section return"><dt>Returns</dt><dd>Tuple of the number of bytes sent and whether all data was sent. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>on failure</td></tr>
  </table>
  </dd>
</dl>
<p>Send all buffered data on the client side to the server. Clients should call this function before blocking. On success, the number of bytes sent to the server is returned.</p>
<p><a class="el" href="classwayland_1_1display__t.html#ad8c76ff1bc339afa823d1eab3ad00042" title="Send all buffered requests on the display to the server.">display_t::flush()</a> never blocks. It will write as much data as possible, but if all data could not be written, the second element in the returned tuple will be set to false. In that case, use poll on the display file descriptor to wait for it to become writable again. </p>

</div>
</div>
<a id="a8a77c6eab2f2eb4cfcca56be8a780d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a77c6eab2f2eb4cfcca56be8a780d3e">&#9670;&nbsp;</a></span>get_class()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string wayland::proxy_t::get_class </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the interface name (class) of a proxy object. </p>
<dl class="section return"><dt>Returns</dt><dd>The interface name of the object associated with the proxy </dd></dl>

</div>
</div>
<a id="a3333b70e8edb633874c70a068ea6f794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3333b70e8edb633874c70a068ea6f794">&#9670;&nbsp;</a></span>get_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wayland::display_t::get_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the last error that occurred on a display. </p>
<dl class="section return"><dt>Returns</dt><dd>The last error that occurred on display or 0 if no error occurred</dd></dl>
<p>Return the last error that occurred on the display. This may be an error sent by the server or caused by the local client.</p>
<p>Note: Errors are fatal. If this function returns non-zero the display can no longer be used. </p>

</div>
</div>
<a id="a3f6b8855f9982c99ace3c5964df8d8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6b8855f9982c99ace3c5964df8d8af">&#9670;&nbsp;</a></span>get_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wayland::display_t::get_fd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a display context's file descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>Display object file descriptor</dd></dl>
<p>Return the file descriptor associated with a display so it can be integrated into the client's main loop. </p>

</div>
</div>
<a id="a273d7fd6604b65d4c4d24747b639a263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273d7fd6604b65d4c4d24747b639a263">&#9670;&nbsp;</a></span>get_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t wayland::proxy_t::get_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the id of a proxy object. </p>
<dl class="section return"><dt>Returns</dt><dd>The id the object associated with the proxy </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="dump_8cpp-example.html#a6">dump.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a78598b90a108f72d6835917d8b2cc1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78598b90a108f72d6835917d8b2cc1c5">&#9670;&nbsp;</a></span>get_registry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwayland_1_1registry__t.html">registry_t</a> wayland::display_t::get_registry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get global registry object </p>
<p>This request creates a registry object that allows the client to list and bind the global objects available from the compositor. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="dump_8cpp-example.html#a2">dump.cpp</a>, <a class="el" href="egl_8cpp-example.html#a18">egl.cpp</a>, <a class="el" href="foreign_display_8cpp-example.html#a3">foreign_display.cpp</a>, <a class="el" href="proxy_wrapper_8cpp-example.html#a6">proxy_wrapper.cpp</a>, and <a class="el" href="shm_8cpp-example.html#a20">shm.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a59444022b75257f6b27d2c464c371779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59444022b75257f6b27d2c464c371779">&#9670;&nbsp;</a></span>get_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t wayland::proxy_t::get_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the protocol object version of a proxy object. </p>
<p>Gets the protocol object version of a proxy object, or 0 if the proxy was created with unversioned API.</p>
<p>A returned value of 0 means that no version information is available, so the caller must make safe assumptions about the object's real version.</p>
<p><a class="el" href="classwayland_1_1display__t.html">display_t</a> will always return version 0.</p>
<dl class="section return"><dt>Returns</dt><dd>The protocol object version of the proxy or 0 </dd></dl>

</div>
</div>
<a id="a65253c6ac727496735c0dc42a9fd1568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65253c6ac727496735c0dc42a9fd1568">&#9670;&nbsp;</a></span>get_wrapper_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwayland_1_1proxy__t.html#afc44f0d53890db6bd32d9b2f0c6994e9">wrapper_type</a> wayland::proxy_t::get_wrapper_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of a proxy object. </p>

<p class="definition">Definition at line <a class="el" href="wayland-client_8hpp_source.html#l00288">288</a> of file <a class="el" href="wayland-client_8hpp_source.html">wayland-client.hpp</a>.</p>

</div>
</div>
<a id="ad00648a8a69ff81ca0291e662b82bc08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00648a8a69ff81ca0291e662b82bc08">&#9670;&nbsp;</a></span>obtain_queue_read_intent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwayland_1_1read__intent.html">read_intent</a> wayland::display_t::obtain_queue_read_intent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Announce calling thread's intention to read events from the Wayland display file descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>event queue for which the read event will be valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classwayland_1_1read__intent.html">read_intent</a> for this display and the specified event queue </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>on failure</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="classwayland_1_1display__t.html#afbc3da19815c40564dcd923ce7d83961">obtain_read_intent</a> for details. </p>

</div>
</div>
<a id="afbc3da19815c40564dcd923ce7d83961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc3da19815c40564dcd923ce7d83961">&#9670;&nbsp;</a></span>obtain_read_intent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwayland_1_1read__intent.html">read_intent</a> wayland::display_t::obtain_read_intent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Announce calling thread's intention to read events from the Wayland display file descriptor. </p>
<p>This ensures that until the thread is ready to read and calls <a class="el" href="classwayland_1_1read__intent.html#a92565efbf3a622eb23fc5aefcb1a033d">read_intent::read</a>, no other thread will read from the file descriptor. During preparation, all undispatched events in the event queue are dispatched until the queue is empty.</p>
<p>Use this function before polling on the display fd or to integrate the fd into a toolkit event loop in a race-free way.</p>
<p>Typical usage is:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> read_intent = display.obtain_read_intent();</div>
<div class="line">display.flush();</div>
<div class="line">poll(fds, nfds, -1); <span class="comment">// Custom poll() handling is possible here</span></div>
<div class="line"><span class="keywordflow">if</span>(fd.revents &amp; POLLIN)</div>
<div class="line">  read_intent.read();</div>
<div class="line">display.dispatch_pending();</div>
</div><!-- fragment --><p>The <a class="el" href="classwayland_1_1read__intent.html">read_intent</a> ensures that if the above code e.g. throws an exception before actually reading from the file descriptor or times out in poll(), the read intent is always cancelled so other threads can proceed.</p>
<p>In one thread, do not hold more than one read intent for the same display at the same time, irrespective of the event queue.</p>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classwayland_1_1read__intent.html">read_intent</a> for this display and the default event queue </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>on failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafa72a9121fa69ccfad6e9eff8740b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa72a9121fa69ccfad6e9eff8740b5e">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wayland::proxy_t::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this wrapper actually wraps an object. </p>
<dl class="section return"><dt>Returns</dt><dd>true if there is an underlying object, false if this wrapper is empty </dd></dl>

</div>
</div>
<a id="ac460e26f384624eb96647d533314240a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac460e26f384624eb96647d533314240a">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wayland::proxy_t::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwayland_1_1proxy__t.html">proxy_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether two wrappers refer to different objects. </p>

</div>
</div>
<a id="a3dc433db4597e77caccb07f99b26a259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc433db4597e77caccb07f99b26a259">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wayland::proxy_t::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwayland_1_1proxy__t.html">proxy_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether two wrappers refer to the same object. </p>

</div>
</div>
<a id="a11eb8b5d61dfdf782fdec43b40fade00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11eb8b5d61dfdf782fdec43b40fade00">&#9670;&nbsp;</a></span>proxy_create_wrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwayland_1_1display__t.html">display_t</a> wayland::display_t::proxy_create_wrapper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create proxy wrapper for this display </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="proxy_wrapper_8cpp-example.html#a4">proxy_wrapper.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0c596640d7469447cb0b91dc9c8c22b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c596640d7469447cb0b91dc9c8c22b2">&#9670;&nbsp;</a></span>proxy_has_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wayland::proxy_t::proxy_has_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this wrapper actually wraps an object. </p>
<dl class="section return"><dt>Returns</dt><dd>true if there is an underlying object, false if this wrapper is empty </dd></dl>

</div>
</div>
<a id="a0af69af8f839a5a5ea354e52705e9a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af69af8f839a5a5ea354e52705e9a43">&#9670;&nbsp;</a></span>proxy_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wayland::proxy_t::proxy_release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the wrapped object (if any), making this an empty wrapper. </p>
<p>Note that <a class="el" href="classwayland_1_1display__t.html" title="Represents a connection to the compositor and acts as a proxy to the display singleton object.">display_t</a> instances cannot be released this way. Attempts to do so are ignored. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="foreign_display_8cpp-example.html#a1">foreign_display.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a61af681e532c101f2511781e2af59bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61af681e532c101f2511781e2af59bb8">&#9670;&nbsp;</a></span>roundtrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wayland::display_t::roundtrip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block until all pending request are processed by the server. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of dispatched events </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>on failure</td></tr>
  </table>
  </dd>
</dl>
<p>Blocks until the server process all currently issued requests and sends out pending events on all event queues. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="dump_8cpp-example.html#a7">dump.cpp</a>, <a class="el" href="egl_8cpp-example.html#a21">egl.cpp</a>, and <a class="el" href="shm_8cpp-example.html#a23">shm.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a49ebb1e2ccf3fed3c4c6f15d95700e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ebb1e2ccf3fed3c4c6f15d95700e20">&#9670;&nbsp;</a></span>roundtrip_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wayland::display_t::roundtrip_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block until all pending request are processed by the server. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of dispatched events </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>on failure</td></tr>
  </table>
  </dd>
</dl>
<p>Blocks until the server processes all currently issued requests and sends out pending events on the event queue.</p>
<p>Note: This function uses <a class="el" href="classwayland_1_1display__t.html#a967a3e54ca3bffb6ba05abf44aef1840" title="Dispatch events in an event queue.">dispatch_queue()</a> internally. If you are using read_events() from more threads, don't use this function (or make sure that calling <a class="el" href="classwayland_1_1display__t.html#a49ebb1e2ccf3fed3c4c6f15d95700e20" title="Block until all pending request are processed by the server.">roundtrip_queue()</a> doesn't interfere with calling prepare_read() and read_events()) </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="proxy_wrapper_8cpp-example.html#a9">proxy_wrapper.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2065bb6f0ba51f29fdf16b8168bb5958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2065bb6f0ba51f29fdf16b8168bb5958">&#9670;&nbsp;</a></span>set_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wayland::proxy_t::set_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwayland_1_1event__queue__t.html">event_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a proxy to an event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The event queue that will handle this proxy</td></tr>
  </table>
  </dd>
</dl>
<p>Assign proxy to event queue. Events coming from proxy will be queued in queue instead of the display's main queue.</p>
<p>See also: <a class="el" href="classwayland_1_1display__t.html#a967a3e54ca3bffb6ba05abf44aef1840" title="Dispatch events in an event queue.">display_t::dispatch_queue()</a>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="proxy_wrapper_8cpp-example.html#a5">proxy_wrapper.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a957166bc2dd6b48cce65b290d446d3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957166bc2dd6b48cce65b290d446d3ba">&#9670;&nbsp;</a></span>sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwayland_1_1callback__t.html">callback_t</a> wayland::display_t::sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>asynchronous roundtrip </p>
<p>The sync request asks the server to emit the 'done' event on the returned <a class="el" href="classwayland_1_1callback__t.html" title="callback object">callback_t</a> object. Since requests are handled in-order and events are delivered in-order, this can be used as a barrier to ensure all previous requests and the resulting events have been handled.</p>
<p>The object returned by this request will be destroyed by the compositor after the callback is fired and as such the client must not attempt to use it after that point. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="wayland-client_8hpp_source.html">wayland-client.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>wayland</b></li><li class="navelem"><a class="el" href="classwayland_1_1display__t.html">display_t</a></li>
    <li class="footer">Generated on Tue Oct 8 2019 20:07:40 for Wayland++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
